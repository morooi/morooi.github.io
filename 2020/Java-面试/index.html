<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一些容易忘掉的知识点 - Java - morooi&#039;s Blog - morooi 的个人展示🍓</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="morooi&#039;s Blog - morooi 的个人展示🍓"><meta name="msapplication-TileImage" content="img/touch-icon-iphone.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="morooi&#039;s Blog - morooi 的个人展示🍓"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="img/touch-icon-iphone.png"><link rel="apple-touch-icon" sizes="152x152" href="img/touch-icon-ipad.png"><meta name="description" content="1 Java 基础1.1 快速失败（fail-fast）和安全失败（fail-safe）机制快速失败（fail-fast）是 Java 集合的一种错误检测机制。 在使用迭代器对集合进行遍历的时候，在多线程下操作非安全失败（fail-safe）的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 在单线程下，如果在遍历过程中"><meta property="og:type" content="blog"><meta property="og:title" content="一些容易忘掉的知识点 - Java"><meta property="og:url" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/"><meta property="og:site_name" content="morooi&#039;s Blog - morooi 的个人展示🍓"><meta property="og:description" content="1 Java 基础1.1 快速失败（fail-fast）和安全失败（fail-safe）机制快速失败（fail-fast）是 Java 集合的一种错误检测机制。 在使用迭代器对集合进行遍历的时候，在多线程下操作非安全失败（fail-safe）的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 在单线程下，如果在遍历过程中"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/asList.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/selector.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/buffer.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/channel.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/hashmap_put.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/hashmap_resize.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/classloader.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/Java异常类层次结构图.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/zhuangtai.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/bianqian.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/sisuo.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/threadpool.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/volatile-1.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/volatile-2.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/beforeG1.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/G1Model.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/G1.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/jvm.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/img_innerjoin.gif"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/img_leftjoin.gif"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/img_rightjoin.gif"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/springcloud.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-1.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-2.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-3.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/filterandinterceptor.jpg"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"><meta property="og:image" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/linux_quanxian.jpg"><meta property="og:image" content="https://javaguide.cn/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB-7c1098a0.png"><meta property="article:published_time" content="2020-08-16T08:05:01.000Z"><meta property="article:modified_time" content="2023-08-21T10:29:26.363Z"><meta property="article:author" content="SJ Zhou"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/asList.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/"},"headline":"一些容易忘掉的知识点 - Java","image":["https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/asList.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/selector.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/buffer.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/channel.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/hashmap_put.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/hashmap_resize.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/classloader.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/Java异常类层次结构图.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/zhuangtai.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/bianqian.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/sisuo.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/threadpool.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/volatile-1.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/volatile-2.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/beforeG1.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/G1Model.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/G1.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/jvm.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/img_innerjoin.gif","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/img_leftjoin.gif","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/img_rightjoin.gif","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/springcloud.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-1.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-2.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-3.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/filterandinterceptor.jpg","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png","https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/linux_quanxian.jpg","https://javaguide.cn/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB-7c1098a0.png"],"datePublished":"2020-08-16T08:05:01.000Z","dateModified":"2023-08-21T10:29:26.363Z","author":{"@type":"Person","name":"SJ Zhou"},"publisher":{"@type":"Organization","name":"morooi's Blog - morooi 的个人展示🍓","logo":{"@type":"ImageObject","url":{"text":"morooi's Blog"}}},"description":"1 Java 基础1.1 快速失败（fail-fast）和安全失败（fail-safe）机制快速失败（fail-fast）是 Java 集合的一种错误检测机制。 在使用迭代器对集合进行遍历的时候，在多线程下操作非安全失败（fail-safe）的集合类可能就会触发 fail-fast 机制，导致抛出 ConcurrentModificationException 异常。 在单线程下，如果在遍历过程中"}</script><link rel="canonical" href="https://morooi.com/2020/Java-%E9%9D%A2%E8%AF%95/"><link rel="icon" href="/img/icon-32x32.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Lato:wght@400"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?15cece15ce32e027e81c277a94bbd778";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-0T8JD2VS0K" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-0T8JD2VS0K');</script><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">morooi&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">全部文章</a><a class="navbar-item" href="/categories">分类</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/morooi"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-08-16T08:05:01.000Z" title="8/16/2020, 4:05:01 PM">2020-08-16</time>发表</span><span class="level-item"><time dateTime="2023-08-21T10:29:26.363Z" title="8/21/2023, 6:29:26 PM">2023-08-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="level-item">3 小时读完 (大约25994个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">一些容易忘掉的知识点 - Java</h1><div class="content"><h2 id="1-Java-基础"><a href="#1-Java-基础" class="headerlink" title="1 Java 基础"></a>1 Java 基础</h2><h3 id="1-1-快速失败（fail-fast）和安全失败（fail-safe）机制"><a href="#1-1-快速失败（fail-fast）和安全失败（fail-safe）机制" class="headerlink" title="1.1 快速失败（fail-fast）和安全失败（fail-safe）机制"></a>1.1 快速失败（fail-fast）和安全失败（fail-safe）机制</h3><p>快速失败（<code>fail-fast</code>）是 Java 集合的一种错误检测机制。</p>
<p>在<strong>使用迭代器</strong>对集合进行遍历的时候，在多线程下操作非安全失败（<code>fail-safe</code>）的集合类可能就会触发 <code>fail-fast</code> 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p>在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 <code>fail-fast</code> 机制。</p>
<blockquote>
<p>例如：多线程下，如果线程 1 正在对集合进行遍历，此时线程 2 对集合进行修改（增加、删除、修改），或者线程 1 在遍历过程中对集合进行修改，都会导致线程 1 抛出 <code>ConcurrentModificationException</code> 异常。</p>
</blockquote>
<p>原理</p>
<p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。</p>
<p>每当迭代器使用 hashNext ()/next () 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>采用<strong>安全失败（<code>fail-safe</code>）</strong>机制的集合容器（JUC 包下的容器），在遍历时不是直接在集合内容上访问的，而是先<strong>复制原有集合内容，在拷贝的集合上进行遍历</strong>，可以在多线程下并发使用，并发修改。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p>
<h3 id="1-2-HashMap-与-ConcurrentHashMap-对-null-值的处理问题"><a href="#1-2-HashMap-与-ConcurrentHashMap-对-null-值的处理问题" class="headerlink" title="1.2 HashMap 与 ConcurrentHashMap 对 null 值的处理问题"></a>1.2 HashMap 与 ConcurrentHashMap 对 null 值的处理问题</h3><p><strong>结论：HashMap 的 key 和 value 都可以为 null，ConcurrentHashMap 的均不可以为 null</strong></p>
<blockquote>
<p>HashTable 也是不允许 key 和 value 为空的，原因和 ConcurrentHashMap 一致</p>
</blockquote>
<p>上源码！</p>
<p>HashMap，当 key 为 null 的时候，hash 值为 0，后续的 put 方法中也没有判断 value 是否为 null 的代码。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>ConcurrentHashMap，key 或 value 为 null 直接抛出空指针异常！</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> {</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    ......</span><br></pre></td></tr></tbody></table></figure>

<p><strong>这么做的原因：</strong></p>
<p>会有一个问题，当通过 <code>get(k)</code> 获取对应的 value 时，如果获取到的是 null，无法判断它是 <code>put(k,v)</code> 的时候 value 为 null，还是这个 key 从来没有做过映射。</p>
<p>HashMap 多用于非并发场景中，可以通过 <code>contains(key)</code> 来做这个判断。而在多用于并发场景中的 ConcurrentHashMap 中调用 <code>m.contains(key)</code> 判断然后再 <code>m.get(key)</code> 时，m 可能已经被其他线程修改而不同了。为了避免这种二义性，ConcurrentHashMap 在设计之初就直接令 key 和 value 都不为 null。</p>
<span id="more"></span>

<h3 id="1-3-Arrays-asList"><a href="#1-3-Arrays-asList" class="headerlink" title="1.3 Arrays.asList()"></a>1.3 Arrays.asList()</h3><p>参考：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-precautions-for-use.html#%E6%95%B0%E7%BB%84%E8%BD%AC%E9%9B%86%E5%90%88">数组转集合</a></p>
<p>《阿里巴巴 Java 开发手册》对 <code>Arrays.asList()</code> 的描述：</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/asList.jpg"></p>
<p><strong>注意 1</strong> 传递的数组必须是对象数组，而不是基本类型。</p>
<p>因为 <code>Arrays.asList()</code> 是泛型方法，传入的对象必须是对象数组。对基本类型来说，可以使用包装类型数组可以解决这个问题。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意 2</strong> 使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code> 会抛出异常。</p>
<p><code>Arrays.asList()</code> 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);  <span class="comment">// 运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);  <span class="comment">// 运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();  <span class="comment">// 运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-4-Java-中用到的排序算法"><a href="#1-4-Java-中用到的排序算法" class="headerlink" title="1.4 Java 中用到的排序算法"></a>1.4 Java 中用到的排序算法</h3><p><strong><code>Arrays.sort()</code></strong></p>
<p>在该方法的源码中调用了 <code>DualPivotQuicksort.sort()</code>，发现在此方法中有如下判断：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> left, <span class="type">int</span> right,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span>[] work, <span class="type">int</span> workBase, <span class="type">int</span> workLen)</span> {</span><br><span class="line">    <span class="comment">// Use Quicksort on small arrays</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) {</span><br><span class="line">        sort(a, left, right, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>

<p>可以发现如果数组的长度小于 <code>QUICKSORT_THRESHOLD</code> 的话就会使用<strong>双轴快速排序</strong>（DualPivotQuicksort），这个值为 286。</p>
<p>在双轴快速排序中，有如下判断。如果数组长度小于 <code>INSERTION_SORT_THRESHOLD</code> == 47，则使用<strong>插入排序</strong>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use insertion sort on tiny arrays</span></span><br><span class="line"><span class="keyword">if</span> (length &lt; INSERTION_SORT_THRESHOLD) {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果数组长度不小于 286，会继续检查该数组的连续升序和连续降序性好不好 (Check if the array is nearly sorted)，如果好的话就用<strong>归并排序</strong>，不好就用<strong>双轴快速排序</strong>。</p>
<p>总结：<code>Arrays.sort()</code> 方法，如果数组长度小于 286 且大于等于 47 的话就用<strong>双轴快速排序</strong>，如果长度小于 47 的话就用<strong>插入排序</strong>。如果数组长度大于等于 286 且连续性好的话，就用 <strong>TimSort 归并排序</strong>（归并排序的优化版本），如果大于等于 286 且连续性不好的话就用<strong>双轴快速排序</strong>。</p>
<table>
<thead>
<tr>
<th align="center">数组长度 <code>l</code></th>
<th align="center">排序方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>l</code> &lt; 47</td>
<td align="center"> 插入排序</td>
</tr>
<tr>
<td align="center"> 47 &lt;= <code>l</code> &lt; 286</td>
<td align="center"> 双轴快速排序</td>
</tr>
<tr>
<td align="center"> 286 &lt;= <code>l</code> （连续性好）</td>
<td align="center">TimSort 归并排序</td>
</tr>
<tr>
<td align="center"> 286 &lt;= <code>l</code> （连续性不好）</td>
<td align="center">双轴快速排序</td>
</tr>
</tbody></table>
<p><strong><code>Collections.sort()</code></strong></p>
<p>针对集合类容器排序，首先调用 <code>this.toArray()</code> 方法将集合元素放进 <code>Object</code> 数组，使用 <code>Array.sort()</code> 的重载方法对该 <code>Object</code> 数组排序。如果用户指定 <code>LegacyMergeSort.userRequested == true</code>，则使用<strong>归并排序</strong>，否则使用 <strong>TimSort 排序</strong> </p>
<h3 id="1-5-BIO、NIO"><a href="#1-5-BIO、NIO" class="headerlink" title="1.5 BIO、NIO"></a>1.5 BIO、NIO</h3><p>同步和异步：</p>
<ul>
<li><p><strong>同步</strong>：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在 A-&gt;B 事件模型中，你需要先完成 A 才能执行 B。 再换句话说，同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</p>
</li>
<li><p><strong>异步</strong>：两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</p>
</li>
</ul>
<p>阻塞和非阻塞：</p>
<ul>
<li><strong>阻塞</strong>：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞</strong>：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<p>在程序里：</p>
<ul>
<li>同步阻塞，相当于一个线程在等待。</li>
<li>同步非阻塞，相当于一个线程在正常运行。</li>
<li>异步阻塞，相当于多个线程都在等待。</li>
<li>异步非阻塞，相当于多个线程都在正常运行。</li>
</ul>
<p><strong>BIO</strong>：同步阻塞 IO (Blocking I/O)</p>
<ul>
<li>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以使用线程池机制改善。</li>
<li>BIO 方式适用于连接数比较小且固定的架构</li>
</ul>
<p><strong>NIO</strong>：同步非阻塞 IO（New I/O, Non-blocking I/O）</p>
<ul>
<li>同步非阻塞，服务器实现为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器（Selector）上，Selector 轮询到连接有 IO 请求时才启动一个线程进行处理</li>
<li> NIO 适用于连接数目多且比较短的架构，比如聊天服务器，编程复杂，JDK1.4 才开始支持</li>
</ul>
<p><strong>为什么 NIO 是同步非阻塞的？</strong></p>
<p>因为无论多少客户端都可以接入服务端，客户端接入并不会耗费一个线程，只会创建一个连接然后注册到 Selector 上去，这样就可以去干其他想干的其他事情了。一个 Selector 线程不断的轮询所有的 Socket 连接（Channel），发现有事件了就通知，然后就启动一个线程处理一个请求即可，这个过程的话就是<strong>非阻塞</strong>的。但是这个处理的过程中，还是要先读取数据，处理，再返回的，这是个<strong>同步</strong>的过程。</p>
<p><strong>多路复用机制是如何支持海量连接？</strong></p>
<p>NIO 的线程模型对 Socket 发起的连接不需要每个都创建一个线程，使用一个 Selector 来多路复用监听 N 多个 Channel 是否有请求，该请求是对应的连接请求，还是发送数据的请求。</p>
<p>一个 Selector 不断的轮询多个 Channel，这样避免了创建多个线程。只有当某个 Channel 有对应的请求的时候才会创建线程，可能说 1000 个请求中只有 100 个请求是有数据交互的，这个时候可能 Server 端就提供 10 个线程就能够处理这些请求。这样的话就可以避免了创建大量的线程。</p>
<p>选择器 Selector 使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/selector.jpg"></p>
<p><strong>NIO 中的 Buffer 是什么？</strong></p>
<blockquote>
<p> IO 面向流（Stream oriented），NIO 面向缓冲区（Buffer oriented）</p>
</blockquote>
<p>通过 NIO 写数据到文件或者网络，或者是从文件和网络读取数据出来，此时就需要通过 <strong>Buffer 缓冲区</strong>来进行。</p>
<p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，读到缓冲区中；在写入数据时，写入到缓冲区中。任何时候访问 NIO 中的数据，都是通过缓冲区进行操作。</p>
<p>每一种 Java 基本类型（除了 Boolean 类型）都对应有一种缓冲区。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/buffer.jpg"></p>
<p><strong>NIO 中的 Channel 是什么？</strong></p>
<ul>
<li>Channel（通道）是 NIO 中的数据通道，NIO 通过 Channel 进行读写。类似流，但是又有些不同</li>
<li>通道是双向的，既可从 Channel 中读取数据，又可以写数据到 Channel 中。流的读写通常是单向的</li>
<li> Channel 中的数据总是要先读到一个 Buffer 中，或者从 Buffer 中将数据写到 Channel 中。因为 Buffer，Channel 可以异步的读写</li>
</ul>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/channel.jpg"></p>
<h3 id="1-6-HashMap-的-put-方法"><a href="#1-6-HashMap-的-put-方法" class="headerlink" title="1.6 HashMap 的 put() 方法"></a>1.6 HashMap 的 put () 方法</h3><p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/hashmap_put.png"></p>
<p><strong>为什么要重写 hashCode 方法？</strong></p>
<p>保证相同的对象返回相同的 hash 值，不同的对象返回不同的 hash 值。和重写 equals 类似。</p>
<p><strong>hash 算法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>h</code> 右移 16 位，向下传播较高位的影响，异或是合并这些影响。应为在小表中可能永远用不到高位信息。</p>
<h3 id="1-7-HashMap-的-resize-方法"><a href="#1-7-HashMap-的-resize-方法" class="headerlink" title="1.7 HashMap 的 resize() 方法"></a>1.7 HashMap 的 resize () 方法</h3><p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/hashmap_resize.png"></p>
<p><strong>为什么链表大小超过 8 个时会自动转化为红黑树，当删除小于 6 时重新变为链表？</strong></p>
<p>根据泊松分布，在负载因子默认为 0.75 的时候，单个 hash 槽内元素个数为 8 的概率小于百万分之一，所以将 7 作为一个分水岭，等于 7 的时候不转换，大于等于 8 的时候才进行转换，小于等于 6 的时候就化为链表。</p>
<p><strong>loadFactor 为什么默认为 0.75？</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么数组中存放的数据（entry）也就越多、越密，会让链表的长度增加；loadFactor 越小，也就是趋近于 0，数组中存放的数据（entry）也就越少，也就越稀疏。</p>
<p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。</p>
<h3 id="1-8-HashMap-获取所有的-Key"><a href="#1-8-HashMap-获取所有的-Key" class="headerlink" title="1.8 HashMap 获取所有的 Key"></a>1.8 HashMap 获取所有的 Key</h3><p>遍历获取 HashMap 中所有的 value 时，使用遍历 EntrySet 的方法比先取 KeySet 再取值快。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();  <span class="comment">// 获取所有的 key</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();  <span class="comment">// 获取所有的 entry</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entrySet) {</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();  <span class="comment">// 单个 entry 的 key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();  <span class="comment">// 单个 entry 的 value</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-9-ConcurrentHashMap"><a href="#1-9-ConcurrentHashMap" class="headerlink" title="1.9 ConcurrentHashMap"></a>1.9 ConcurrentHashMap</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AixdbEiXf3KfE724kg2YIw">ConcurrentHashMap &amp; Hashtable</a></p>
<p>JDK 1.8 中：采用了 <strong>自旋 + CAS + synchronized</strong> 来保证并发安全性。跟 HashMap 很像，把 Node 中的 <strong>value 和 next 使用 volatile 修饰</strong>，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是 8）。</p>
<p>ConcurrentHashMap 的 put 操作大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hashcode</li>
<li> 判断是否需要进行初始化，若需要，执行 <code>initTable()</code></li>
<li>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>, 则需要进行扩容 <code>helpTransfer()</code></li>
<li>如果都不满足，则利用 synchronized 锁写入数据</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树</li>
</ol>
<p>ConcurrentHashMap 的初始化 <code>initTable()</code> 是通过<strong>自旋和 CAS</strong> 操作完成的。里面需要注意的是变量 <code>sizeCtl</code> ，它的值决定着当前的初始化状态。</p>
<ol>
<li>-1 说明正在初始化</li>
<li> -N 说明有 N-1 个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table 已经初始化。</li>
</ol>
<h3 id="1-10-内部类有什么作用"><a href="#1-10-内部类有什么作用" class="headerlink" title="1.10 内部类有什么作用"></a>1.10 内部类有什么作用</h3><ul>
<li><p><strong>封装性</strong></p>
<p>作为一个类的编写者，很显然需要对这个类的使用访问者的访问权限做出一定的限制，将一些我们不愿意让别人看到的操作隐藏起来，如果我们的内部类不想轻易被任何人访问，可以选择使用 private 修饰内部类（对于普通类是不能用的），这样我们就无法通过创建对象的方法来访问，想要访问只需要在外部类中定义一个 public 修饰的方法，间接调用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">test</span> <span class="keyword">implements</span> <span class="title class_">Demo</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> {</span><br><span class="line">            System.out.println(<span class="string">"密码备份文件"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Demo <span class="title function_">getInner</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>实现多继承</strong></p>
<p>Java 是不可以实现多继承的，一次只能继承一个类，可以用接口来实现多继承的效果，即一个接口有多个实现，但是这里也是有一点弊端的，那就是，一旦实现一个接口就必须实现里面的所有方法，有时候就会出现一些累赘，但是使用内部类可以很好的解决这些问题。</p>
<p>编写两个待继承的类 Demo1 和 Demo2，在 MyDemo 类中书写了两个内部类，test1 和 test2 两者分别继承了 Demo1 和 Demo2 类，这样 MyDemo 中就间接的实现了多继承。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> {</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"BWH_Steven"</span>;</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> {</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">email</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"xxx.@163.com"</span>;</span><br><span class="line">      }</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDemo</span> {</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">test1</span> <span class="keyword">extends</span> <span class="title class_">Demo1</span> {</span><br><span class="line">          <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> {</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.name();</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">test2</span> <span class="keyword">extends</span> <span class="title class_">Demo2</span>  {</span><br><span class="line">          <span class="keyword">public</span> String <span class="title function_">email</span><span class="params">()</span> {</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">super</span>.email();</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">test1</span>().name();</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">email</span><span class="params">()</span> {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">test2</span>().email();</span><br><span class="line">      }</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">          <span class="type">MyDemo</span> <span class="variable">md</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDemo</span>();</span><br><span class="line">          System.out.println(<span class="string">"我的姓名:"</span> + md.name());</span><br><span class="line">          System.out.println(<span class="string">"我的邮箱:"</span> + md.email());</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="1-11-创建对象的几种方式"><a href="#1-11-创建对象的几种方式" class="headerlink" title="1.11 创建对象的几种方式"></a>1.11 创建对象的几种方式</h3><ol>
<li><p>使用 new 关键字（最常见）</p>
</li>
<li><p>使用 Class 类的 <code>newInstance()</code> 方法（反射）</p>
<p>只能调用无参构造函数，不能调用私有的构造函数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)Class.forName(<span class="string">"cn.morooi.User"</span>).newInstance();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.class.newInstance();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用 Constructor 类的 <code>newInstance()</code> 方法（反射）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> Class.forName(<span class="string">"cn.morooi.User"</span>).getConstructor();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)constructor.newInstance()</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>使用 <code>clone()</code> 方法（不会调用任何构造函数）</p>
</li>
<li><p>反序列化</p>
</li>
</ol>
<h3 id="1-12-双亲委派机制"><a href="#1-12-双亲委派机制" class="headerlink" title="1.12 双亲委派机制"></a>1.12 双亲委派机制</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/classloader.html">类加载器详解</a></p>
<p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
<p><strong>好处</strong>：</p>
<p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p>
<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p>
<p><strong>三个 Classloader</strong>：</p>
<ul>
<li><code>BootstrapClassLoader</code>（启动类加载器）：最顶层的加载类，由 C++ 实现，负责加载 <code>%JAVA_HOME%/lib</code> 目录下的 jar 包和类或者或被 <code>-Xbootclasspath</code> 参数指定的路径中的所有类。</li>
<li><code>ExtensionClassLoader</code>（扩展类加载器）：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li>
<li><code>AppClassLoader</code>（应用程序类加载器）：面向用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>
</ul>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/classloader.png"></p>
<h3 id="1-13-实现只读集合"><a href="#1-13-实现只读集合" class="headerlink" title="1.13 实现只读集合"></a>1.13 实现只读集合</h3><p><code>Collections.unmodifiable...()</code> 可以实现只读集合</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> </span><br><span class="line">   <span class="keyword">throws</span> Exception {</span><br><span class="line">      <span class="type">List</span> <span class="variable">stuff</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[] { <span class="string">"a"</span>, <span class="string">"b"</span> });</span><br><span class="line">      <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(stuff);</span><br><span class="line">      list = Collections.unmodifiableList(list);</span><br><span class="line">      <span class="keyword">try</span> {</span><br><span class="line">         list.set(<span class="number">0</span>, <span class="string">"new value"</span>);</span><br><span class="line">      } </span><br><span class="line">        <span class="keyword">catch</span> (UnsupportedOperationException e) {</span><br><span class="line">      }</span><br><span class="line">      <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(stuff);</span><br><span class="line">      set = Collections.unmodifiableSet(set);</span><br><span class="line">      <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">      map = Collections.unmodifiableMap(map);</span><br><span class="line">      System.out.println(<span class="string">"集合现在是只读"</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-14-接口和抽象类的区别"><a href="#1-14-接口和抽象类的区别" class="headerlink" title="1.14 接口和抽象类的区别"></a>1.14 接口和抽象类的区别</h3><ol>
<li>接口方法的默认修饰符是 public，在 JDK 8 以前所有方法在接口中不能有实现。JDK 8 中可以在接口中定义默认方法和静态方法。静态方法直接用接口名调用，实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写。</li>
<li>抽象方法可以有 public、protected 和 default 这些修饰符，也可以有非抽象的方法。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口中的变量只能用 static final 修饰，不能有其他变量，而抽象类中则不一定。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
<li>JDK 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h3 id="1-15-类的生命周期、类加载过程"><a href="#1-15-类的生命周期、类加载过程" class="headerlink" title="1.15 类的生命周期、类加载过程"></a>1.15 类的生命周期、类加载过程</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/class-loading-process.html">类加载过程详解</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/jvm/java-jvm-classload.html">Java 类加载机制</a></p>
<p>Java 类加载过程通常分为以下三个阶段：</p>
<p><strong>1. 加载（Loading）</strong></p>
<ul>
<li>在加载阶段，类加载器负责查找类的字节码文件并将其加载到内存中。类加载器根据类的全名（包括包路径）来查找对应的 .class 文件。 </li>
<li>找到类文件后，将其读取到内存中，并创建一个表示该类的 Class 对象。</li>
<li>类加载器可以是系统类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）或应用程序类加载器（Application ClassLoader）</li>
</ul>
<p><strong>2. 链接（Linking）</strong></p>
<p>链接阶段进一步分为三个步骤：</p>
<ul>
<li>验证（Verification）：Java 虚拟机执行验证步骤以确保类文件的完整性和合法性。这包括检查字节码文件的格式、语法和语义，以防止安全漏洞和运行时错误。</li>
<li>准备（Preparation）：Java 虚拟机为类的静态变量分配内存空间，并设置默认初始值，例如数字类型的默认值是 0，对象引用的默认值是 null。这些变量的内存分配在类加载阶段进行，而不是在类初始化阶段。</li>
<li>解析（Resolution）：解析是可选的步骤，根据需要执行。在解析阶段，虚拟机将符号引用（如类、方法、字段的引用）转换为直接引用，以便在后续的类初始化和运行中快速访问类和其成员。</li>
</ul>
<p><strong>3. 初始化（Initialization）</strong></p>
<ul>
<li>初始化是类加载的最后一个阶段。在初始化阶段，Java 虚拟机执行类的初始化代码，这包括执行静态初始化块和静态字段初始化。初始化阶段确保在使用类之前，类的状态已经准备好。 </li>
<li>类的初始化是一个延迟操作，只有在首次使用类时才会触发。</li>
</ul>
<p>类初始化的时机包括：</p>
<ul>
<li>创建类的实例（对象初始化时）。 </li>
<li>调用类的静态方法。 </li>
<li>访问类的静态字段（除 final 常量外）。 </li>
<li>初始化类的子类。</li>
</ul>
<p>Java 的类加载机制确保了类的懒加载（只有在需要时才加载）和类初始化的顺序。每个类只会被加载和初始化一次，除非它被卸载（通常不会发生）。这个机制有助于提高性能和节省内存。</p>
<h3 id="1-16-几个容器的声明"><a href="#1-16-几个容器的声明" class="headerlink" title="1.16 几个容器的声明"></a>1.16 几个容器的声明</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {...}</span><br><span class="line">    </span><br><span class="line"><span class="comment">// LinkedList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcurrentHashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashTable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">// CopyOnWriteArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {...}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable {...}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="1-17-StringBuilder-和-StringBuffer-的区别"><a href="#1-17-StringBuilder-和-StringBuffer-的区别" class="headerlink" title="1.17 StringBuilder 和 StringBuffer 的区别"></a>1.17 StringBuilder 和 StringBuffer 的区别</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string">String、StringBuffer、StringBuilder 的区别？</a></p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 抽象类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串 <code>char[]value</code>，但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 的方法都是调用父类的方法实现的，区别在于 <code>StringBuffer</code> 的方法都使用 <code>synchronized</code> 关键字修饰保证线程安全。</p>
<h3 id="1-18-错误与异常"><a href="#1-18-错误与异常" class="headerlink" title="1.18 错误与异常"></a>1.18 错误与异常</h3><p>Java 中所有的异常都继承于 <code>java.lang.Throwable</code> 类。Throwable 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong>。</p>
<img src="/2020/Java-%E9%9D%A2%E8%AF%95/Java异常类层次结构图.png" style="zoom:70%;">

<ul>
<li><strong>错误 Error</strong>：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
<li><strong>异常 Exception</strong>：是程序本身可以处理的异常。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong>（下标越界异常）</li>
</ul>
<p><strong>异常和错误的区别：异常能被程序本身处理，错误无法处理</strong></p>
<h3 id="1-19-String-类的一些用法"><a href="#1-19-String-类的一些用法" class="headerlink" title="1.19 String 类的一些用法"></a>1.19 String 类的一些用法</h3><ul>
<li><p><strong>新建一个 String 对象</strong></p>
  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"s"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"s"</span>);  <span class="comment">// s2 == "s"</span></span><br><span class="line"><span class="type">char</span>[] chars = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>};</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);  <span class="comment">// s3 == "abcd"</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// s4 == "bc"</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">65</span>, <span class="number">66</span>};</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);  <span class="comment">// s5 == "AB"</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取子串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> s.substring(s, <span class="number">2</span>);  <span class="comment">// s1 == "cdef"</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.substring(s, <span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 == "cd"，左闭右开区间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"aa"</span>.concat(<span class="string">"bb"</span>).concat(<span class="string">"cc"</span>);  <span class="comment">// s == "aabbcc", 相当于 "aa" + "bb" + "cc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找参数字符串在本字符串中首次出现的索引位置，没有返回 -1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"I am a good student"</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> str.indexOf(<span class="string">'a'</span>);  <span class="comment">// a == 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> str.indexOf(<span class="string">"good"</span>);  <span class="comment">// b == 7</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> str.indexOf(<span class="string">"w"</span>, <span class="number">2</span>);  <span class="comment">// c == -1，该方法从第二个参数位置向后查找</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> str.lastIndexOf(<span class="string">"a"</span>);  <span class="comment">// d == 5，该方法从字符串的末尾位置向前查找</span></span><br><span class="line"><span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> str.lastIndexOf(<span class="string">"a"</span>, <span class="number">3</span>);  <span class="comment">// e == 2，该方法从第二个参数位置向前查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray();  <span class="comment">// 将当前字符串拆分成为字符数组作为返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes();  <span class="comment">// 获取当前字符串底层的字节数组</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span>;  <span class="comment">//返回将当前字符串中所有字符转换成小写后的新串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span>;  <span class="comment">//返回将当前字符串中所有字符转换成大写后的新串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="comment">// 将所有出现的老字符串替换成为新的字符串，返回替换后的结果新字符串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(CharSequence oldString, CharSequence newString)</span>;</span><br><span class="line"><span class="comment">// 用字符 replacement 的内容替换当前字符串中遇到的第一个和字符串 regex 相匹配的子串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span>;</span><br><span class="line"><span class="comment">// 用字符 replacement 的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉空格</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span>;  <span class="comment">// 去掉首尾的空格，中间的不处理</span></span><br><span class="line">str.replace(<span class="string">" "</span>, <span class="string">""</span>);  <span class="comment">// 使用 replace() 方法去掉所有空格，包括首尾、中间</span></span><br><span class="line">str.replaceAll(<span class="string">" "</span>, <span class="string">""</span>);  <span class="comment">// 使用 replaceAll() 方法去掉所有空格，包括首尾、中间</span></span><br><span class="line">str.replaceAll(<span class="string">"\\s*"</span>, <span class="string">""</span>);  <span class="comment">// 使用 replaceAll() 方法去掉所有空白字符，包括空格、制表符、换页符等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割</span></span><br><span class="line"><span class="keyword">public</span> String[] split(String regex);  <span class="comment">// 按照参数规则将字符串切分成若干部分，返回 String 数组</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>字符串与基本类型的转换</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型转字符串，使用 String 类中的 valueOf() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> data[])</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> data[], <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">float</span> f)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> d)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转基本类型，使用基本类型的包装类中的 parseXxx() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span> <span class="title function_">parseByte</span><span class="params">(String s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">parseShort</span><span class="params">(String s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">parseLong</span><span class="params">(String s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">parseFloat</span><span class="params">(String s)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">parseDouble</span><span class="params">(String s)</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="1-20-线程安全的容器"><a href="#1-20-线程安全的容器" class="headerlink" title="1.20 线程安全的容器"></a>1.20 线程安全的容器</h3><ul>
<li>同步容器：<code>HashTable</code>, <code>Vector</code></li>
<li>并发容器：<code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code>, <code>CopyOnWriteArraySet</code></li>
<li>队列：<code>ConcurrentLinkedQueue</code>, <code>ConcurrentLinkedDeque</code></li>
<li>阻塞队列：<code>ArrayBlockingQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>DelayQueue</code>, <code>SynchronousQueue</code></li>
</ul>
<h3 id="1-21-HashMap-为什么线程不安全"><a href="#1-21-HashMap-为什么线程不安全" class="headerlink" title="1.21 HashMap 为什么线程不安全"></a>1.21 HashMap 为什么线程不安全</h3><p>HashMap 不是线程安全的主要原因是多个线程可以同时修改 HashMap 中的键值对，导致不一致性。具体来说，当两个线程同时尝试在 HashMap 中添加或删除键值对时，可能会发生以下情况：</p>
<ol>
<li>两个线程同时调用 put 方法并且插入相同的键，这会导致其中一个线程的插入操作被覆盖，并且可能会导致该键值对丢失。</li>
<li>当一个线程正在调用 put 方法添加键值对时，另一个线程同时调用 get 方法来获取相同的键值对，这可能会导致 get 方法返回旧值，而不是最新的值。</li>
<li>当一个线程正在调用 put 方法添加键值对时，另一个线程同时调用 remove 方法来删除相同的键值对，这可能会导致删除失败或者删除了错误的键值对。</li>
</ol>
<h3 id="1-22-HashMap-为什么扩容总是-2-的幂次"><a href="#1-22-HashMap-为什么扩容总是-2-的幂次" class="headerlink" title="1.22 HashMap 为什么扩容总是 2 的幂次"></a>1.22 HashMap 为什么扩容总是 2 的幂次</h3><p>HashMap 的扩容总是 2 的幂次方，是因为这样可以在进行哈希映射计算时，用位运算的方式代替除法运算，从而提高运算速度。</p>
<p>具体来说，在 HashMap 中，对于一个 key，它的哈希值会先通过以下方式转换为在数组中的索引位置：<code>index = (hash &amp; (capacity - 1))</code></p>
<p>其中，**<code>hash</code>** 是 key 的哈希值，**<code>capacity</code>** 是数组的容量，**<code>&amp;</code>** 是按位与运算符。这种转换方式可以保证 <strong><code>index</code></strong> 的值不会超过数组的大小，而且可以均匀地分布在数组中。</p>
<p>如果数组的大小不是 2 的幂次，那么 <strong><code>(capacity - 1)</code></strong> 得到的值的二进制表示中会有一些 0 后面跟着一些 1，这样做位运算时就会多次执行操作。而如果数组大小是 2 的幂次，**<code>(capacity - 1)</code>** 得到的值的二进制表示中所有的位都是 1，这样做位运算时只需要执行一次操作就可以了。</p>
<p>此外，由于扩容时需要将所有的元素重新计算索引位置并放到新数组中，如果数组大小是 2 的幂次，那么元素的索引位置计算也会更加高效。这是因为，如果数组大小是 2 的幂次，那么元素在新数组中的索引位置要么不变，要么变为原索引位置加上旧数组大小。这种计算方式只需要用位运算来实现，非常高效。</p>
<p>综上所述，HashMap 的扩容总是 2 的幂次方，可以提高运算速度并且使得索引位置的计算更加高效。</p>
<h3 id="1-23-HashMap-为什么要用红黑树-不用其他树"><a href="#1-23-HashMap-为什么要用红黑树-不用其他树" class="headerlink" title="1.23 HashMap 为什么要用红黑树 不用其他树"></a>1.23 HashMap 为什么要用红黑树 不用其他树</h3><p>在 HashMap 的实现中，当链表长度达到一定阈值时，会将链表转换为红黑树。这是因为红黑树相对于其他树，有以下优势：</p>
<ol>
<li>查询、插入和删除的时间复杂度为 O (log n)，与平衡树的性质有关，相对于链表的线性复杂度，性能更高。</li>
<li>红黑树相对于其他平衡树来说，实现比较简单，而且旋转操作次数较少，因此更适合在 HashMap 中使用。</li>
</ol>
<p>红黑树是一种自平衡二叉搜索树，能够保证树的高度始终在 O (log n) 的范围内，从而保证了插入、删除和查询的时间复杂度都能够达到 O (log n)。</p>
<p>相对于其他平衡树如 AVL 树，红黑树的旋转操作较少，实现较为简单，而且能够保证插入、删除和查询的时间复杂度也能够达到 O (log n)，因此更适合在 HashMap 中使用。</p>
<h3 id="1-24-HashMap-为什么到-8-的时候变为红黑树"><a href="#1-24-HashMap-为什么到-8-的时候变为红黑树" class="headerlink" title="1.24 HashMap 为什么到 8 的时候变为红黑树"></a>1.24 HashMap 为什么到 8 的时候变为红黑树</h3><p>当链表长度较小时，使用链表能够较为高效地进行查找、插入和删除操作，而且实现比较简单。但是当链表长度较大时，链表的性能会逐渐变差，因为查找、插入和删除操作的时间复杂度为 O (n)。</p>
<p>为了解决这个问题，Java 8 引入了红黑树来替代链表，因为红黑树能够保证插入、删除和查找的时间复杂度为 O (log n)，相对于链表而言具有更好的性能表现。而 8 这个阈值是通过经验和实验得到的一个比较优秀的值，能够在实际使用中达到较好的性能表现。</p>
<p>需要注意的是，当红黑树中节点数目小于等于 6 时，HashMap 又会将红黑树转换为链表（在 resize 的时候），这是为了避免红黑树的过度复杂化和占用过多的内存空间。</p>
<h3 id="1-25-符号引用和直接引用"><a href="#1-25-符号引用和直接引用" class="headerlink" title="1.25 符号引用和直接引用"></a>1.25 符号引用和直接引用</h3><p><strong>1. 符号引用（Symbolic Reference）</strong></p>
<ul>
<li>符号引用是在编译阶段生成的，它用符号来表示要引用的类、方法、字段等元素，而不包含具体的内存地址或偏移量信息。 </li>
<li>符号引用提供了元素的名称、类型以及所在类的引用，但它不包含具体的内存地址。这使得编译器和链接器可以在后续的处理阶段（如类加载阶段）进行解析，并将符号引用映射到具体的内存地址或偏移量。</li>
<li>符号引用的使用使得 Java 虚拟机能够支持动态链接和类加载，因为它们可以在运行时动态解析为直接引用。</li>
</ul>
<p><strong>2. 直接引用（Direct Reference）</strong></p>
<ul>
<li>直接引用是在虚拟机执行时实际使用的引用，它包含了元素的内存地址或偏移量信息，可以直接访问该元素。 </li>
<li>直接引用通常在符号引用解析之后生成，以便虚拟机能够高效地访问类、方法、字段等元素。 </li>
<li>直接引用的使用使得虚拟机能够快速访问内存中的数据，而不需要重新计算或查找。</li>
</ul>
<p>总结来说，符号引用是编程语言在编译阶段使用的抽象引用，不包含具体的内存地址信息，而直接引用是在执行阶段使用的实际引用，包含了元素的内存地址或偏移量信息，以便能够直接访问数据。在类加载和链接过程中，符号引用会被解析为直接引用，以便程序可以正确地执行。这种分离使得 Java 虚拟机能够支持动态链接和类加载，并且在执行时具有高效的内存访问。</p>
<h2 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2 多线程"></a>2 多线程</h2><h3 id="2-1-sleep-、wait-、join-的区别"><a href="#2-1-sleep-、wait-、join-的区别" class="headerlink" title="2.1 sleep()、wait()、join() 的区别"></a>2.1 sleep ()、wait ()、join () 的区别</h3><ul>
<li><code>sleep()</code> 是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，<strong>不会释放对象锁</strong>，到时间自动恢复。</li>
<li><code>wait()</code> 是 Object 的方法，并且<strong>只能在同步方法或同步块中使用</strong>，如果当前线程不是锁的持有者，该方法抛出一个 <code>IllegalMonitorStateException</code> 异常。<strong>调用会放弃对象锁</strong>，进入等待队列，待调用 <code>notify() / notifyAll()</code> 唤醒指定的线程或者所有线程后才会进入锁池，再次获得对象锁才会进入运行状态。</li>
<li><code>join()</code> 是线程线程类（Thread）的方法，调用 <code>join()</code> 方法不会释放锁，调用线程会一直等待被调用的线程执行完毕（转换为 TERMINATED 状态）</li>
<li><code>sleep()</code> 方法可以在任何地方使用，并且必须要指定时间，<code>wait()</code> 方法则只能在同步方法或同步块中使用。</li>
</ul>
<h3 id="2-2-线程的生命周期和状态"><a href="#2-2-线程的生命周期和状态" class="headerlink" title="2.2 线程的生命周期和状态"></a>2.2 线程的生命周期和状态</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/zhuangtai.png"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/bianqian.png"></p>
<h3 id="2-3-锁升级"><a href="#2-3-锁升级" class="headerlink" title="2.3 锁升级"></a>2.3 锁升级</h3><p>见：<a target="_blank" rel="noopener" href="http://concurrent.redspider.group/article/02/9.html">synchronize 与锁</a></p>
<p><strong>锁的升级流程</strong></p>
<p>每一个线程在准备获取共享资源时：</p>
<ol>
<li>检查 MarkWord 里面是不是放的自己的 ThreadId , 如果是，表示当前线程是处于 “偏向锁”</li>
<li> 如果 MarkWord 不是自己的 ThreadId，锁升级，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空</li>
<li>两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord</li>
<li> 第三步中成功执行 CAS 的获得资源，失败的则进入自旋</li>
<li>自旋的线程在自旋过程中，成功获得资源 (即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败</li>
<li>进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己</li>
</ol>
<p>总的来说，先使用<strong>偏向锁</strong>优先同一线程然后再次获取锁，如果失败，就升级为 <strong>CAS 轻量级锁</strong>，如果失败就会短暂<strong>自旋</strong>，防止线程被系统挂起。最后如果以上都失败就升级为<strong>重量级锁</strong>。</p>
<p><strong>各种锁的优缺点对比</strong></p>
<table>
<thead>
<tr>
<th align="center">锁</th>
<th>优点</th>
<th>缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td align="left">适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td>
<td align="left">追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td>线程竞争不使用自旋，不会消耗 CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td align="left">追求吞吐量。同步块执行时间较长。</td>
</tr>
</tbody></table>
<h3 id="2-4-线程为什么比进程快"><a href="#2-4-线程为什么比进程快" class="headerlink" title="2.4 线程为什么比进程快"></a>2.4 线程为什么比进程快</h3><p><strong>进程和线程的区别</strong></p>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如 I/O）</strong>：</p>
<ul>
<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>
<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</li>
<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li>
</ul>
<p>另外一个重要区别是，<strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即 CPU 分配时间的单位 。</p>
<h3 id="2-5-使用多线程的好处"><a href="#2-5-使用多线程的好处" class="headerlink" title="2.5 使用多线程的好处"></a>2.5 使用多线程的好处</h3><p><strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p>
<p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p>
<ul>
<li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li>
<li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li>
</ul>
<h3 id="2-6-使用多线程可能会带来的问题"><a href="#2-6-使用多线程可能会带来的问题" class="headerlink" title="2.6 使用多线程可能会带来的问题"></a>2.6 使用多线程可能会带来的问题</h3><p><strong>内存泄漏</strong></p>
<p><strong>死锁</strong></p>
<p>线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/sisuo.png"></p>
<p>死锁发生的条件：</p>
<ol>
<li>互斥条件：资源 <code>x</code> 的任意一个时刻只被一个线程持有</li>
<li>占有且等待：线程 1 占有资源 <code>x</code> 的同时等待资源 <code>y</code> ，并不释放 <code>x</code></li>
<li>不可抢占：资源 <code>x</code> 一旦被线程 1 占有，其他线程不能抢占 <code>x</code></li>
<li>循环等待：线程 1 持有 <code>x</code>，等待 <code>y</code>，线程 2 持有 <code>y</code>，等待 <code>x</code>，当全部满足时才会死锁</li>
</ol>
<p>避免死锁：</p>
<ol>
<li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li><strong>破坏占有且等待</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不可抢占</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</li>
<li>使用 <code>tryLock</code> 方法（ReentrantLock、ReentrantReadWriteLock），设置超时时间，超时可以退出防止死锁。</li>
</ol>
<p><strong>线程不安全</strong></p>
<h3 id="2-7-synchronized-与-Lock-的区别"><a href="#2-7-synchronized-与-Lock-的区别" class="headerlink" title="2.7 synchronized 与 Lock 的区别"></a>2.7 synchronized 与 Lock 的区别</h3><table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left"> synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="left"> 存在层次</td>
<td align="left"> Java 的关键字，在 JVM 层面上</td>
<td>是一个类</td>
</tr>
<tr>
<td align="left">锁的释放</td>
<td align="left"> 1. 已获取锁的线程执行完同步代码，释放锁<br>2. 线程执行发生异常，JVM 会让线程释放锁</td>
<td>必须在 finally 中释放锁，不然容易造成线程死锁</td>
</tr>
<tr>
<td align="left">锁的获取</td>
<td align="left">假设 A 线程获得锁，B 线程等待<br>如果 A 线程阻塞，B 线程会一直等待</td>
<td>分情况而定，Lock 有多个锁获取的方式<br>大致就是可以尝试获得锁，线程可以不用一直等待</td>
</tr>
<tr>
<td align="left">锁状态</td>
<td align="left">无法判断</td>
<td>可以判断</td>
</tr>
<tr>
<td align="left">锁类型</td>
<td align="left">可重入、不可中断、非公平</td>
<td>可重入、可判断、可公平（两者皆可）</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">少量同步</td>
<td>大量同步</td>
</tr>
</tbody></table>
<p><strong>synchronized 有什么不足之处？</strong></p>
<ul>
<li>如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，<strong>同一时间只能有一个线程执行</strong>。</li>
<li>synchronized 无法知道线程有没有成功获取到锁</li>
<li>使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li>
</ul>
<p><strong>Lock 接口有什么优势？</strong></p>
<ul>
<li>可以使锁更公平</li>
<li>可以使线程在等待锁的时候响应中断</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁</li>
</ul>
<p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的（tryLock 方法）、定时的（tryLock 带参方法）、可中断的（lockInterruptibly）、可多条件队列的（newCondition 方法）锁操作。另外 Lock 的实现类基本都支持非公平锁（默认）和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p>
<p><strong>ReentrantLock</strong></p>
<p>ReentrantLock 是 Lock 接口的 JDK 默认实现，特点：</p>
<ul>
<li><p>可重入锁</p>
</li>
<li><p>支持公平锁和非公平锁，<strong>默认为非公平锁</strong></p>
<p>在 ReentrantLock 的构造方法里，可以传入一个 <code>boolean</code> 类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过 <code>isFair()</code> 方法来查看。</p>
</li>
<li><p>是排他锁，独占不能共享</p>
</li>
</ul>
<p><strong>ReentrantReadWriteLock</strong></p>
<p>ReentrantReadWriteLock 是 ReadWriteLock 接口的 JDK 默认实现，特点：</p>
<ul>
<li>可重入锁</li>
<li>支持公平锁和非公平锁，<strong>默认为非公平锁</strong></li>
<li>支持读写锁，在 “写” 操作的时候，其它线程不能写也不能读，称这种现象为 “写饥饿”。</li>
</ul>
<p><strong>StampedLock</strong></p>
<p>StampedLock 把读分为了悲观读和乐观读，悲观读就等价于 ReadWriteLock 的读，而乐观读在一个线程写共享变量时，不会被阻塞，乐观读是不加锁的。所以没锁肯定是比有锁的性能好，这样的话在大并发读情况下效率就更高了。StampedLock 在获取锁和乐观读时，都会返回一个 stamp，解锁时需要传入这个 stamp，在乐观读时是用来验证共享变量是否被其他线程写过。</p>
<h3 id="2-8-线程池"><a href="#2-8-线程池" class="headerlink" title="2.8 线程池"></a>2.8 线程池</h3><p>来自：<a target="_blank" rel="noopener" href="http://concurrent.redspider.group/article/03/12.html">线程池原理</a></p>
<p>使用线程池主要有以下三个原因：</p>
<ol>
<li>创建 / 销毁线程需要消耗系统资源，线程池可以<strong>复用已创建的线程</strong>。</li>
<li><strong>控制并发的数量</strong>。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）</li>
<li><strong>可以对线程做统一管理</strong>。</li>
</ol>
<p>Java 中的线程池顶层接口是 <code>Executor</code> 接口，<code>ThreadPoolExecutor</code> 是这个接口的实现类。</p>
<p><strong>四种常见的线程池</strong></p>
<p><code>Executors</code> 类中提供的几个静态方法来创建线程池。</p>
<ul>
<li><p><code>newFixedThreadPool</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>核心线程数量和总线程数量相等</strong>，都是传入的参数 <code>nThreads</code>，所以只能创建核心线程，不能创建非核心线程。</p>
</li>
<li><p><code>newSingleThreadExecutor</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有且仅有一个核心线程（corePoolSize == maximumPoolSize == 1），使用了 LinkedBlockingQueue（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>
</li>
<li><p><code>newCachedThreadPool</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不创建核心线程，线程池最大为 <code>Integer.MAX_VALUE</code>。尝试将任务添加到 SynchronousQueue 队列。如果 SynchronousQueue 入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从 SynchronousQueue 拉取任务并在当前线程执行。如果 SynchronousQueue 已有任务在等待，入列操作将会阻塞。</p>
</li>
<li><p><code>newScheduledThreadPool</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// class ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> {</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建一个定长线程池，支持定时及周期性任务执行。</p>
</li>
</ul>
<p><strong>线程池的参数</strong></p>
<ul>
<li><p><code>int corePoolSize</code>：该线程池中<strong>核心线程数最大值</strong></p>
</li>
<li><p><code>int maximumPoolSize</code>：该线程池中<strong>线程总数最大值</strong>。(等于核心线程数量 + 非核心线程数量)</p>
</li>
<li><p><code>long keepAliveTime</code>：<strong>非核心线程闲置超时时长</strong>。</p>
<blockquote>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。</p>
<p>如果设置 <code>allowCoreThreadTimeOut(true)</code>，则会也作用于核心线程。</p>
</blockquote>
</li>
<li><p><code>TimeUnit unit</code>：keepAliveTime 的单位。</p>
</li>
<li><p><code>BlockingQueue workQueue</code>：阻塞队列，维护着<strong>等待执行的 Runnable 任务对象</strong>。</p>
</li>
<li><p><code>ThreadFactory threadFactory</code>：创建线程的工厂 ，用于批量创建线程。</p>
</li>
<li><p><code>RejectedExecutionHandler handler</code>：拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略。</p>
</li>
</ul>
<p><strong>核心线程</strong>：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p>
<p><strong>常用的几个阻塞队列</strong>：</p>
<ol>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>链式阻塞队列，底层数据结构是链表，默认大小是 <code>Integer.MAX_VALUE</code>，也可以指定大小。</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p>
</li>
<li><p><strong>SynchronousQueue</strong></p>
<p>同步队列，内部容量为 0，每个 put 操作必须等待一个 take 操作，反之亦然。</p>
</li>
<li><p><strong>DelayQueue</strong></p>
<p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</p>
</li>
</ol>
<p><strong>四种拒绝处理策略</strong>：</p>
<ol>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出 RejectedExecutionException 异常。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li>
</ol>
<p><strong>线程池主要的任务处理流程</strong>：</p>
<ol>
<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到 corePoolSize，在核心线程数量 &lt; corePoolSize 时）。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>线程总数量 &gt;= corePoolSize 时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li>
<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些 “临时工” 来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>缓存队列满了， 且总线程数达到了 maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>
</ol>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/threadpool.png"></p>
<h3 id="2-9-ThreadLocal"><a href="#2-9-ThreadLocal" class="headerlink" title="2.9 ThreadLocal"></a>2.9 ThreadLocal</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html">Java 并发 - ThreadLocal 详解</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/threadlocal.html">ThreadLocal 详解</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/428bb2eafea3640ad6a97be5a">ThreadLocal 到底会不会内存泄漏？实战直接告诉你答案！</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lqlqlq/p/13302901.html">证明：ThreadLocal 的 get,set 方法无法防止内存泄漏</a></p>
<p><a target="_blank" rel="noopener" href="https://java.isture.com/java/thread/java-thread-y-threadlocal-interview.html">ThreadLocal 面试场景</a></p>
<h3 id="2-10-volatile"><a href="#2-10-volatile" class="headerlink" title="2.10 volatile"></a>2.10 volatile</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html">volatile 详解</a></p>
<p><strong>volatile 为什么可以保证内存可见性？</strong></p>
<blockquote>
<p>volatile 是在汇编层面加 Lock，使用缓存一致性协议（MESI）解决并发可见性的。</p>
</blockquote>
<p>为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存 (L1，L2 或其他) 后再进行操作，但操作完不知道何时会写到内存。</p>
<p>如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</p>
<p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议（MESI），每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p>
<p>volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
<p><strong>volatile 是怎么禁止指令重排序的？</strong></p>
<p>volatile 关键字通过内存屏障（Memory Barrier）来禁止指令重排序。</p>
<ul>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 </li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 </li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 </li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li>
</ul>
<p>通过插入这些屏障，volatile 变量的读写操作的顺序在编译器和处理器中都得到了限制，保证了它们的顺序与代码中的顺序一致。这样就避免了在多线程环境下由于指令重排而导致的读取脏数据的问题。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/volatile-1.png"></p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/volatile-2.png"></p>
<h2 id="3-JVM"><a href="#3-JVM" class="headerlink" title="3 JVM"></a>3 JVM</h2><h3 id="3-1-CMS-收集器"><a href="#3-1-CMS-收集器" class="headerlink" title="3.1 CMS 收集器"></a>3.1 CMS 收集器</h3><p>来自：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM 垃圾回收详解</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59861022">G1 收集器</a></p>
<p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。</p>
<p>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是一种 “标记 - 清除” 算法实现的，整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记</strong>：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。</li>
<li><strong>并发标记</strong>：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记</strong>：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清除</strong>：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/CMS%E6%94%B6%E9%9B%86%E5%99%A8.png"></p>
<p>主要优点：并发收集、低停顿</p>
<p>主要缺点：</p>
<ul>
<li>对 CPU 资源敏感</li>
<li>无法处理浮动垃圾</li>
<li>它使用的 “标记 - 清除” 算法会导致收集结束时会有大量空间碎片产生</li>
</ul>
<h3 id="3-2-G1-收集器"><a href="#3-2-G1-收集器" class="headerlink" title="3.2 G1 收集器"></a>3.2 G1 收集器</h3><p>来自：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM 垃圾回收详解</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59861022">G1 收集器</a></p>
<p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征.</p>
<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>
<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>
<li><strong>空间整合</strong>：与 CMS 的 “标记 - 清理” 算法不同，G1 从整体来看是基于 “标记 - 整理” 算法实现的收集器，从局部上来看是基于 “复制” 算法实现的。</li>
<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>
</ul>
<p>G1 之前的 JVM 内存模型</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/beforeG1.jpg"></p>
<p>G1 收集器的内存模型</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/G1Model.jpg"></p>
<h4 id="G1堆内存结构"><a href="#G1堆内存结构" class="headerlink" title="G1堆内存结构"></a>G1 堆内存结构</h4><p>堆内存会被切分成为很多个固定大小区域（Region），每个是连续范围的虚拟内存。</p>
<p>堆内存中一个区域（Region）的大小可以通过 <code>-XX:G1HeapRegionSize</code> 参数指定，大小区间最小 1M、最大 32M，总之是 2 的幂次方。</p>
<p>默认把堆内存按照 2048 份均分。</p>
<h4 id="G1堆内存分配"><a href="#G1堆内存分配" class="headerlink" title="G1堆内存分配"></a>G1 堆内存分配</h4><p>每个 Region 被标记了 E、S、O 和 H，这些区域在逻辑上被映射为 Eden，Survivor 和老年代。</p>
<p>存活的对象从一个区域转移（即复制或移动）到另一个区域。区域被设计为并行收集垃圾，可能会暂停所有应用线程。</p>
<p>如上图所示，区域可以分配到 Eden，survivor 和老年代。此外，还有第四种类型，被称为巨型区域（Humongous Region）。Humongous 区域是为了那些存储超过 50% 标准 region 大小的对象而设计的，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。</p>
<h4 id="G1回收流程"><a href="#G1回收流程" class="headerlink" title="G1回收流程"></a>G1 回收流程</h4><p>G1 收集器的运作大致分为以下几个步骤（类似于 CMS 收集器）：</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/G1.jpg"></p>
<ul>
<li><strong>初始标记</strong>：这个阶段是 STW (Stop the World) 的，所有应用线程会被暂停，标记出从 GC Root 开始直接可达的对象。</li>
<li><strong>并发标记</strong>：从 GC Roots 开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当并发标记完成后，开始最终标记（Final Marking）阶段</li>
<li><strong>最终标记</strong>：标记那些在并发标记阶段发生变化的对象，将被回收。</li>
<li><strong>筛选回收</strong>：首先对各个 Regin 的回收价值和成本进行排序，根据用户所期待的 GC 停顿时间指定回收计划，回收一部分 Region。</li>
</ul>
<p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region (这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
<h3 id="3-3-Java-内存中各部分的内容"><a href="#3-3-Java-内存中各部分的内容" class="headerlink" title="3.3 Java 内存中各部分的内容"></a>3.3 Java 内存中各部分的内容</h3><p>参考：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/memory-area.html">Java 内存区域详解</a>、<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903663496871943">可能是把 Java 内存区域讲的最清楚的一篇文章</a></p>
<p><strong>线程共享的</strong></p>
<ul>
<li><p>堆</p>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
</li>
<li><p>方法区</p>
<p>各个线程共享的内存区域，它用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>
</li>
<li><p>运行时常量池<br><del>JDK1.7 前在方法区中，1.7 及之后在 Java 堆中的一块区域存放运行时常量池，用于<strong>存放编译期生成的各种字面量和符号引用。</strong></del></p>
<ol>
<li>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区，此时 hotspot 虚拟机对方法区的实现为永久代 </li>
<li>JDK1.7 字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是 hotspot 中的永久代</li>
<li> JDK1.8 hotspot 移除了永久代用元空间 (Metaspace) 取而代之，这时候字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间 (Metaspace)</li>
</ol>
</li>
</ul>
<p><strong>线程私有的</strong></p>
<ul>
<li><p>程序计数器</p>
<p>唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p>两个作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ul>
</li>
<li><p>虚拟机栈</p>
<p>由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、操作数栈、动态链接、方法出口信息</p>
<p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
</li>
<li><p>本地方法栈</p>
<p>和虚拟机栈所发挥的作用非常相似，虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，本地方法栈则为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
</li>
</ul>
<h3 id="3-4-永久代会有垃圾回收吗"><a href="#3-4-永久代会有垃圾回收吗" class="headerlink" title="3.4 永久代会有垃圾回收吗"></a>3.4 永久代会有垃圾回收吗</h3><p>永久代也是可以回收的，条件是</p>
<ol>
<li><p>该类的实例都被回收</p>
</li>
<li><p>加载该类的 classLoader 已经被回收</p>
</li>
<li><p>该类不能通过反射访问到其方法，而且该类的 <code>java.lang.class</code> 没有被引用</p>
</li>
</ol>
<p>当满足这 3 个条件时，是可以回收，但回不回收还得看 JVM。</p>
<h3 id="3-5-JDK-8-的默认垃圾回收器"><a href="#3-5-JDK-8-的默认垃圾回收器" class="headerlink" title="3.5 JDK 8 的默认垃圾回收器"></a>3.5 JDK 8 的默认垃圾回收器</h3><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 可以查看</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br><span class="line"></span><br><span class="line">-XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4294967296 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version "1.8.0_231"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_231-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)</span><br></pre></td></tr></tbody></table></figure>

<p>其中 UseParallelGC 表示使用 Parallel Scavenge + Parallel Old 垃圾收集器。</p>
<h3 id="3-6-JVM-思维导图"><a href="#3-6-JVM-思维导图" class="headerlink" title="3.6 JVM 思维导图"></a>3.6 JVM 思维导图</h3><p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/jvm.png"></p>
<h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4 数据库"></a>4 数据库</h2><h3 id="4-1-MyISAM-与-InnoDB-的区别"><a href="#4-1-MyISAM-与-InnoDB-的区别" class="headerlink" title="4.1 MyISAM 与 InnoDB 的区别"></a>4.1 MyISAM 与 InnoDB 的区别</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">MyISAM 和 InnoDB 有什么区别？</a></p>
<p>MySQL 5.5 版之前 MyISAM 是默认数据库引擎，5.5 版本后默认的存储引擎为 InnoDB。</p>
<p>两者的对比：</p>
<p>1. 是否支持行级锁</p>
<p>MyISAM 只有表级锁 (table-level locking)，而 <strong>InnoDB 支持行级锁 (row-level locking) 和表级锁</strong>，默认为行级锁</p>
<p>2. 是否支持事务</p>
<p>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交 (commit) 和回滚 (rollback) 事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</p>
<p>3. 是否支持外键</p>
<p>MyISAM 不支持，InnoDB 支持。</p>
<p>4. 是否支持数据库异常崩溃后的安全恢复</p>
<p>MyISAM 不支持，InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log。</p>
<p>5. 是否支持 MVCC</p>
<p>仅 InnoDB 支持。应对高并发事务 MVCC 比单纯的加锁更高效，MVCC 只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作，MVCC 可以使用乐观锁和悲观锁来实现。</p>
<p>总结：</p>
<ul>
<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度</li>
<li> MyISAM 不提供事务支持，InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别</li>
<li> MyISAM 不支持外键，InnoDB 支持</li>
<li> MyISAM 不支持 MVVC，InnoDB 支持</li>
<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样</li>
<li> MyISAM 不支持数据库异常崩溃后的安全恢复，InnoDB 支持</li>
<li> InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
<h3 id="4-2-数据库事务"><a href="#4-2-数据库事务" class="headerlink" title="4.2 数据库事务"></a>4.2 数据库事务</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">Spring 事务详解</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">Spring 事务传播行为详解</a></p>
<h3 id="4-3-数据库索引"><a href="#4-3-数据库索引" class="headerlink" title="4.3 数据库索引"></a>4.3 数据库索引</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/_9rDde9wRYoZeh07EASNQQ">《爱上面试官》系列 - 数据库索引</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-gmAPfiKMNJgHhIZqR2C4A">索引的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/7TPVOT7sloDUKmhldf9uvg">MySQL 的索引是怎么加速查询的？</a></p>
<p>合适建索引的字段：</p>
<ul>
<li>不为 NULL 的字段</li>
<li>被频繁查询的字段</li>
<li>被作为条件查询的字段</li>
<li>被经常频繁用于连接的字段</li>
<li>经常需要排序的列</li>
</ul>
<p>不合适创建索引的字段：</p>
<ul>
<li>被频繁更新的字段</li>
<li>不被经常查询的字段</li>
<li>特大型表的话维护开销会很大，不适合建索引</li>
</ul>
<p>其他注意：</p>
<ul>
<li>注意遵守最左前缀原则</li>
<li>尽可能的考虑建立联合索引而不是单列索引</li>
<li>注意避免冗余索引</li>
<li>考虑在字符串类型的字段上使用前缀索引代替普通索引</li>
</ul>
<h3 id="4-4-SQL-语句的执行过程"><a href="#4-4-SQL-语句的执行过程" class="headerlink" title="4.4 SQL 语句的执行过程"></a>4.4 SQL 语句的执行过程</h3><p>见：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a></p>
<h3 id="4-5-MySQL-的锁机制"><a href="#4-5-MySQL-的锁机制" class="headerlink" title="4.5 MySQL 的锁机制"></a>4.5 MySQL 的锁机制</h3><p>见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34337272/article/details/80611486">MySQL 锁机制简单了解一下</a></p>
<h3 id="4-6-MVCC-多版本并发控制"><a href="#4-6-MVCC-多版本并发控制" class="headerlink" title="4.6 MVCC 多版本并发控制"></a>4.6 MVCC 多版本并发控制</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YEqTMd0OaIhW99WqavgQ">MVCC 和事务隔离级别的关系</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012650596">MySQL-InnoDB-MVCC 多版本并发控制</a></p>
<h3 id="4-7-delete-truncate-drop-删除的区别"><a href="#4-7-delete-truncate-drop-删除的区别" class="headerlink" title="4.7 delete , truncate,  drop 删除的区别"></a>4.7 <code>delete</code> , <code>truncate</code>,  <code>drop</code> 删除的区别</h3><p><strong>特点</strong></p>
<p><code>delete</code>：</p>
<ul>
<li>删除指定数据：<code>delete from test where username = 'abc'</code></li>
<li>删除整个表：<code>delete * from test</code> 或 <code>delete from test</code>，仅删除表内的所有内容，保留表的定义，不释放空间，<strong>可以回滚恢复</strong>。</li>
</ul>
<p><code>drop</code>：<code>drop 表名</code>，删除表，并释放空间，将表删除的一干二净。</p>
<p><code>truncate</code>：<code>truncate 表名</code>，删除表里的内容，并释放空间，但表结构及其列、约束、索引等保持不变。</p>
<p><strong>是否可以恢复？</strong></p>
<ul>
<li><code>delete</code> 语句是数据库操作语言（DML），这个操作会放到 rollback segement 中，事务提交之后才生效，可以回滚。</li>
<li><code>truncate</code> 和 <code>drop</code> 是数据库定义语言（DDL），操作立即生效，原数据不放到 rollback segment 中，不能回滚。</li>
</ul>
<p><strong>执行速度</strong>：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p>
<h3 id="4-8-内连接、左连接、右连接"><a href="#4-8-内连接、左连接、右连接" class="headerlink" title="4.8 内连接、左连接、右连接"></a>4.8 内连接、左连接、右连接</h3><ul>
<li><p>内连接（inner join），交集</p>
<img src="/2020/Java-%E9%9D%A2%E8%AF%95/img_innerjoin.gif">

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> a_table a </span><br><span class="line">	<span class="keyword">inner</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br><span class="line"></span><br><span class="line"># 或省去 <span class="keyword">inner</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> a_table a </span><br><span class="line">	<span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></tbody></table></figure>

<p>以上语句等价于</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> a_table a,</span><br><span class="line">	 b_table b</span><br><span class="line"><span class="keyword">where</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>左外连接（左连接，left outer join），差集</p>
<img src="/2020/Java-%E9%9D%A2%E8%AF%95/img_leftjoin.gif">

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a </span><br><span class="line">	<span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br><span class="line"></span><br><span class="line"># 或省去 <span class="keyword">outer</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a </span><br><span class="line">	<span class="keyword">left</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></tbody></table></figure>

<p>左连接，左表（a_table）的记录将会全部表示出来，而右表（b_table）只会显示符合搜索条件的记录，右表记录不足的地方均为 NULL。</p>
</li>
<li><p>右外连接（右连接，right outer join），差集</p>
<img src="/2020/Java-%E9%9D%A2%E8%AF%95/img_rightjoin.gif">

<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a </span><br><span class="line">	<span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br><span class="line"></span><br><span class="line"># 或省去 <span class="keyword">outer</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> a_table a </span><br><span class="line">	<span class="keyword">right</span> <span class="keyword">join</span> b_table b <span class="keyword">on</span> a.a_id <span class="operator">=</span> b.b_id;</span><br></pre></td></tr></tbody></table></figure>

<p>与左连接相反，右连接，左表（a_table）只会显示符合搜索条件的记录，而右表（b_table）的记录将会全部表示出来。左表记录不足的地方均为 NULL。</p>
<p><strong>右连接可以与左连接等价互换</strong></p>
</li>
<li><p>合并（union），并集</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">union 联合 合并: 将多条查询语句的结果合并成一个结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">语法：</span></span><br><span class="line"><span class="comment">    查询语句1</span></span><br><span class="line"><span class="comment">    union</span></span><br><span class="line"><span class="comment">    查询语句2</span></span><br><span class="line"><span class="comment">    union</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">'%a%'</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">90</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>union</code> 特点：</p>
<ol>
<li>要求多条查询语句的查询列数是一致的</li>
<li>要求多条查询语句的查询的每一列的类型和顺序最好一致</li>
<li><code>union</code> 关键字默认去重，如果使用 <code>union all</code> 可以包含重复项</li>
<li>用于要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</li>
</ol>
</li>
</ul>
<h3 id="4-9-MySQL-中的常用函数"><a href="#4-9-MySQL-中的常用函数" class="headerlink" title="4.9 MySQL 中的常用函数"></a>4.9 MySQL 中的常用函数</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 聚合函数</span><br><span class="line"><span class="built_in">COUNT</span>(col)  # 统计查询结果的行数</span><br><span class="line"><span class="built_in">MIN</span>(col)  # 查询指定列的最小值</span><br><span class="line"><span class="built_in">MAX</span>(col)  # 查询指定列的最大值</span><br><span class="line"><span class="built_in">SUM</span>(col)  # 求和，返回指定列的总和</span><br><span class="line"><span class="built_in">AVG</span>(col)  # 求平均值，返回指定列数据的平均值</span><br><span class="line"></span><br><span class="line"># 数值函数</span><br><span class="line"><span class="built_in">ABS</span>(x) &nbsp;# 返回x的绝对值</span><br><span class="line">BIN(x) &nbsp;# 返回x的二进制</span><br><span class="line"><span class="built_in">CEILING</span>(x) &nbsp;# 返回大于x的最小整数值</span><br><span class="line"><span class="built_in">EXP</span>(x) &nbsp;# 返回值e（自然对数的底）的x次方</span><br><span class="line"><span class="built_in">FLOOR</span>(x) &nbsp;# 返回小于x的最大整数值</span><br><span class="line">GREATEST(x1,x2,...,xn) &nbsp;# 返回集合中最大的值</span><br><span class="line">LEAST(x1,x2,...,xn) &nbsp;# 返回集合中最小的值</span><br><span class="line"><span class="built_in">LN</span>(x) &nbsp;# 返回x的自然对数</span><br><span class="line"><span class="built_in">LOG</span>(x,y) &nbsp;# 返回x的以y为底的对数</span><br><span class="line"><span class="built_in">MOD</span>(x,y) &nbsp;# 返回x<span class="operator">/</span>y的模（余数）</span><br><span class="line">PI() &nbsp;# 返回pi的值（圆周率）</span><br><span class="line">RAND() &nbsp;# 返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值</span><br><span class="line">ROUND(x,y) &nbsp;# 返回参数x的四舍五入的有y位小数的值</span><br><span class="line"><span class="keyword">TRUNCATE</span>(x,y) &nbsp;# 返回数字x截短为y位小数的结果</span><br><span class="line"></span><br><span class="line"># 字符串函数</span><br><span class="line">LENGTH(s) &nbsp;# 计算字符串长度函数，返回字符串的字节长度</span><br><span class="line">CONCAT(s1, s2..., sn) &nbsp;# 合并字符串函数，返回结果为连接参数产生的字符串，参数可以是一个或多个</span><br><span class="line"><span class="keyword">INSERT</span>(str, x, y, instr) &nbsp;# 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</span><br><span class="line"><span class="built_in">LOWER</span>(str) &nbsp;# 将字符串中的字母转换为小写</span><br><span class="line"><span class="built_in">UPPER</span>(str) &nbsp;# 将字符串中的字母转换为大写</span><br><span class="line"><span class="keyword">LEFT</span>(str, x) &nbsp;# 返回字符串str中最左边的x个字符</span><br><span class="line"><span class="keyword">RIGHT</span>(str, x) &nbsp;# 返回字符串str中最右边的x个字符</span><br><span class="line"><span class="built_in">TRIM</span>(str) &nbsp;# 删除字符串左右两侧的空格</span><br><span class="line">REPLACE(s，s1，s2) &nbsp;# 使用字符串 s2 替换字符串 s 中所有的字符串 s1</span><br><span class="line"><span class="built_in">SUBSTRING</span>(s，n，len) &nbsp;# 从字符串 s 返回一个长度同 len 字符相同的子字符串，起始于位置 n</span><br><span class="line">REVERSE(str) &nbsp;# 返回颠倒字符串str的结果</span><br><span class="line"></span><br><span class="line"># 时间函数</span><br><span class="line">CURDATE() <span class="operator">/</span> <span class="built_in">CURRENT_DATE</span>()  # 两个函数作用相同，返回当前系统的日期值</span><br><span class="line">CURTIME() <span class="operator">/</span> <span class="built_in">CURRENT_TIME</span>()  # 两个函数作用相同，返回当前系统的时间值</span><br><span class="line">NOW() <span class="operator">/</span> SYSDATE()  # 两个函数作用相同，返回当前系统的日期和时间值</span><br><span class="line">UNIX_TIMESTAMP()  # 获取 UNIX 时间戳</span><br><span class="line">TIMETOSEC()  # 将时间参数转换为秒数</span><br><span class="line">SECTOTIME()  # 将秒数转换为时间</span><br><span class="line">ADDTIME()  # 时间加法运算，在原始时间上添加指定的时间</span><br><span class="line">SUBTIME()  # 时间减法运算，在原始时间上减去指定的时间</span><br></pre></td></tr></tbody></table></figure>



<h2 id="5-分布式"><a href="#5-分布式" class="headerlink" title="5 分布式"></a>5 分布式</h2><h3 id="5-1-分布式架构"><a href="#5-1-分布式架构" class="headerlink" title="5.1 分布式架构"></a>5.1 分布式架构</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34337272/article/details/80444032">分布式系统的经典基础理论</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/uv9xYgYrHWqM5acXQYFegA">三歪非要听我说完分布式才肯睡</a></p>
<h3 id="5-2-分布式事务"><a href="#5-2-分布式事务" class="headerlink" title="5.2 分布式事务"></a>5.2 分布式事务</h3><p><a target="_blank" rel="noopener" href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/">小米 - 分布式事务，这一篇就够了</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/XknegP66mnYboiBx556Kzw">敖丙 - 分布式事务</a></p>
<ul>
<li>两阶段提交 / XA</li>
<li>TCC (Try-Confirm-Cancel)</li>
<li> 本地消息表</li>
<li>可靠消息最终一致性 (消息事务)</li>
</ul>
<h3 id="5-3-Spring-Cloud-技术图"><a href="#5-3-Spring-Cloud-技术图" class="headerlink" title="5.3 Spring Cloud 技术图"></a>5.3 Spring Cloud 技术图</h3><p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/springcloud.png"></p>
<h2 id="6-Redis"><a href="#6-Redis" class="headerlink" title="6 Redis"></a>6 Redis</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247484609&amp;idx=1&amp;sn=4c053236699fde3c2db1241ab497487b&amp;scene=21#wechat_redirect">缓存雪崩、穿透，缓存与数据库双写一致</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vXBFscXqDcXS_VaIERplMQ">妈妈再也不担心我面试被 Redis 问得脸都绿了</a></p>
<h3 id="6-1-数据库的双写一致性问题"><a href="#6-1-数据库的双写一致性问题" class="headerlink" title="6.1 数据库的双写一致性问题"></a>6.1 数据库的双写一致性问题</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3Fmv7h5p2QDtLxc9n1dp5A">面试前必须要知道的 Redis 面试题</a></p>
<ul>
<li><p><strong>先更新数据库，后删除缓存（多用）</strong></p>
<p>正常的情况是这样的：</p>
<ul>
<li>先操作数据库，成功；</li>
<li>再删除缓存，也成功；</li>
</ul>
<p>如果原子性被破坏了：</p>
<ul>
<li>第一步成功（操作数据库），第二步失败（删除缓存），会导致<strong>数据库里是新数据，而缓存里是旧数据</strong>。</li>
<li>如果第一步（操作数据库）就失败了，我们可以直接返回错误（Exception），不会出现数据不一致。</li>
</ul>
<p>如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p>
<ul>
<li>缓存<strong>刚好</strong>失效</li>
<li>线程 A 查询数据库，得一个旧值</li>
<li>线程 B 将新值写入数据库</li>
<li>线程 B 删除缓存</li>
<li>线程 A 将查到的旧值写入缓存</li>
</ul>
<p>要达成上述情况，还是说一句<strong>概率特别低</strong>：</p>
<blockquote>
<p>因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，<strong>而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存</strong>，所有的这些条件都具备的概率基本并不大。</p>
</blockquote>
<p><strong>删除缓存失败的解决思路</strong>：</p>
<ul>
<li>将需要删除的 key 发送到消息队列中</li>
<li>自己消费消息，获得需要删除的 key</li>
<li><strong> 不断重试删除操作，直到成功</strong></li>
</ul>
</li>
<li><p>先删除缓存，后更新数据库</p>
<p>正常情况是这样的：</p>
<ul>
<li>先删除缓存，成功；</li>
<li>再更新数据库，也成功；</li>
</ul>
<p>如果原子性被破坏了：</p>
<ul>
<li>第一步成功（删除缓存），第二步失败（更新数据库），数据库和缓存的数据还是一致的。</li>
<li>如果第一步（删除缓存）就失败了，我们可以直接返回错误（Exception），数据库和缓存的数据还是一致的。</li>
</ul>
<p>看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：</p>
<ul>
<li>线程 A 删除了缓存</li>
<li>线程 B 查询，发现缓存已不存在</li>
<li>线程 B 去数据库查询得到旧值</li>
<li>线程 B 将旧值写入缓存</li>
<li>线程 A 将新值写入数据库</li>
</ul>
<p>所以也会导致数据库和缓存不一致的问题。</p>
<p><strong>并发下解决数据库与缓存不一致的思路</strong>：</p>
<ul>
<li>将删除缓存、修改数据库、读取缓存等的操作积压到<strong>队列</strong>里边，实现<strong>串行化</strong>。</li>
</ul>
</li>
</ul>
<p>两种策略各自有优缺点：</p>
<ul>
<li><p>先删除缓存，再更新数据库</p>
<p>在高并发下表现不如意，在原子性被破坏时表现优异</p>
</li>
<li><p>先更新数据库，再删除缓存（<code>Cache Aside Pattern</code> 设计模式）</p>
<p>在高并发下表现优异，在原子性被破坏时表现不如意</p>
</li>
</ul>
<h3 id="6-2-RDB-与-AOF"><a href="#6-2-RDB-与-AOF" class="headerlink" title="6.2 RDB 与 AOF"></a>6.2 RDB 与 AOF</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">持久化：RDB 和 AOF 机制详解</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-persistence.html">Redis 持久化机制详解</a></p>
<p><strong>RDB 优点</strong></p>
<ul>
<li>只有一个文件 <code>dump.rdb</code>，<strong>方便持久化</strong>。</li>
<li><strong>容灾性好</strong>，一个文件可以保存到安全的磁盘。</li>
<li><strong>性能最大化</strong>，<code>fork</code> 子进程来完成写操作，让主进程继续处理命令，所以使 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis 的高性能</li>
<li>相对于数据集大时，比 AOF 的 <strong>启动效率</strong> 更高。</li>
</ul>
<p><strong>RDB 缺点</strong></p>
<ul>
<li><strong>数据安全性低</strong>。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。</li>
</ul>
<p><strong>AOF 优点</strong></p>
<ul>
<li><strong>数据安全</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li>
<li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li>
<li>AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li>
</ul>
<p><strong>AOF 缺点</strong></p>
<ul>
<li>AOF 文件比 RDB <strong>文件大</strong>，且<strong>恢复速度慢</strong>。</li>
<li><strong>数据集大</strong>的时候，比 RDB <strong>启动效率低</strong>。</li>
</ul>
<p><strong>Redis 的数据恢复有着如下的优先级</strong></p>
<ol>
<li>如果只配置 AOF ，重启时加载 AOF 文件恢复数据；</li>
<li>如果同时配置了 RDB 和 AOF ，启动只加载 AOF 文件恢复数据；</li>
<li>如果只配置 RDB，启动将加载 dump 文件恢复数据。</li>
</ol>
<blockquote>
<p>有 AOF 就用 AOF，没有就 RDB</p>
</blockquote>
<h3 id="6-3-数据结构"><a href="#6-3-数据结构" class="headerlink" title="6.3 数据结构"></a>6.3 数据结构</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">Redis 数据类型</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-data-types.html">数据类型：5 种基础数据类型详解</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html">数据结构：底层数据结构详解</a></p>
<h3 id="6-4-Redis-集群"><a href="#6-4-Redis-集群" class="headerlink" title="6.4 Redis 集群"></a>6.4 Redis 集群</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html">高可拓展：分片技术（Redis Cluster）详解</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MzU2NDgyNw==&amp;mid=2247487143&amp;idx=1&amp;sn=b095c730e2180d7461c6c0aaa55f495f&amp;source=41#wechat_redirect">史上最强「集群」入门实践教程</a></p>
<h3 id="6-5-Redis-过期-key-的删除策略"><a href="#6-5-Redis-过期-key-的删除策略" class="headerlink" title="6.5 Redis 过期 key 的删除策略"></a>6.5 Redis 过期 key 的删除策略</h3><ul>
<li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个定时器，过期时间到达时，由定时器任务立即执行对应键的删除操作。</li>
<li><strong>惰性删除</strong>：放任键过期不管，但是每次获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</li>
<li><strong>定期删除</strong>：周期性轮训 Redis 库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度。</li>
</ul>
<table>
<thead>
<tr>
<th>删除策略</th>
<th>内存占用</th>
<th> CPU 占用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用 CPU 资源，频度高</td>
<td>用时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU 利用率高</td>
<td>用空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的 CPU 资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<h3 id="6-6-内存淘汰机制"><a href="#6-6-内存淘汰机制" class="headerlink" title="6.6 内存淘汰机制"></a>6.6 内存淘汰机制</h3><ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li>volatile-lfu：当内存不足以容纳新写入数据时，在过期密集的键中，使用 LFU 算法进行删除 key。</li>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，使用 LFU 算法移除所有的 key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期的键中，随机删除一个 key。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，随机删除一个或者多个 key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ul>
<h3 id="6-7-scan-命令"><a href="#6-7-scan-命令" class="headerlink" title="6.7 scan 命令"></a>6.7 scan 命令</h3><blockquote>
<p>1 亿个 key，其中有 10 万个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</p>
</blockquote>
<p>使用 keys 指令可以扫出指定模式的 key 列表。但是它有两个主要的缺点：</p>
<ol>
<li><p>没有 offset、limit 参数，一次性吐出所有满足条件的 key</p>
</li>
<li><p>keys 算法是遍历算法，复杂度是 O (n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，所有读写 Redis 的其它的指令都会被延后甚至会超时报错，因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</p>
</li>
</ol>
<p>scan 相比 keys 具备有以下特点:</p>
<ul>
<li>复杂度虽然也是 O (n)，但是它是通过游标分步进行的，不会阻塞线程</li>
<li>提供 limit 参数，可以控制每次返回结果的最大条数</li>
<li>同 keys 一样，它也提供模式匹配功能</li>
<li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数</li>
<li>返回的结果可能会有重复，需要客户端去重复，这点非常重要</li>
<li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的</li>
<li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为 0</li>
</ul>
<p>scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了 ，但是整体所花费的时间会比直接用 keys 指令长。</p>
<h3 id="6-8-异步队列和延迟队列"><a href="#6-8-异步队列和延迟队列" class="headerlink" title="6.8 异步队列和延迟队列"></a>6.8 异步队列和延迟队列</h3><p><strong>异步队列</strong></p>
<p>Redis 通过 <code>list</code> 数据结构来实现消息队列，主要使用到如下命令：</p>
<ul>
<li><code>lpush</code> 和 <code>rpush</code> 入队列</li>
<li><code>lpop</code> 和 <code>rpop</code> 出队列</li>
<li><code>blpop</code> 和 <code>brpop</code> 阻塞式出队列</li>
</ul>
<p>当队列里面没有消息时，使用 <code>sleep</code> 阻塞一段时间，但是 <code>sleep</code> 会导致消息的处理延迟增加。这个问题我们可以通过 <code>blpop / brpop</code> 来阻塞式读取队列。</p>
<p><code>blpop / brpop</code> 在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。</p>
<p><strong>延迟队列</strong></p>
<p>如下场景：</p>
<ul>
<li>订单下单后超过一小时用户未支付，需要关闭订单</li>
<li>订单的评论如果 7 天未评价，系统需要自动产生一条评论</li>
</ul>
<p>可以使用延时队列，顾名思义就是需要延迟一段时间后执行。Redis 可通过 <code>zset</code> 实现。想要执行时间的时间戳作为 <code>score</code>，消息内容作为 <code>key</code> 调用 <code>zadd</code> 来生产消息，消费者用 <code>zrangebyscore</code> 指令获取 N 秒之前的数据轮询进行处理。</p>
<h3 id="6-9-Redis-线程模型"><a href="#6-9-Redis-线程模型" class="headerlink" title="6.9 Redis 线程模型"></a>6.9 Redis 线程模型</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%87%8D%E8%A6%81">Redis 线程模型</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-redis-single-thread/">为什么 Redis 选择单线程模型</a></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/d01329aceeed184a8e71575ff">美团二面：Redis 究竟是单线程还是多线程？</a></p>
<h2 id="7-Spring-全家桶"><a href="#7-Spring-全家桶" class="headerlink" title="7 Spring 全家桶"></a>7 Spring 全家桶</h2><h3 id="7-1-Spring-中依赖注入的方式"><a href="#7-1-Spring-中依赖注入的方式" class="headerlink" title="7.1 Spring 中依赖注入的方式"></a>7.1 Spring 中依赖注入的方式</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/joemsu/p/7688307.html">浅谈 Spring 为什么推荐使用构造器注入</a></p>
<p>常见的三种注入方式:</p>
<ul>
<li>field 注入</li>
<li>构造器注入（Spring 推荐）</li>
<li>setter 注入</li>
</ul>
<p>构造器注入的好处：</p>
<ol>
<li>保证依赖不可变（final 关键字）</li>
<li>保证依赖不为空（省去了我们对其检查）</li>
<li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li>
<li>避免了循环依赖（如果有循环依赖会主动提醒）</li>
<li>提升了代码的可复用性</li>
</ol>
<h3 id="7-2-Spring-如何解决循环依赖"><a href="#7-2-Spring-如何解决循环依赖" class="headerlink" title="7.2 Spring 如何解决循环依赖"></a>7.2 Spring 如何解决循环依赖</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6985337310472568839">Spring 中的循环依赖及解决</a></p>
<h3 id="7-3-SpringBoot-的启动流程"><a href="#7-3-SpringBoot-的启动流程" class="headerlink" title="7.3 SpringBoot 的启动流程"></a>7.3 SpringBoot 的启动流程</h3><p><a target="_blank" rel="noopener" href="https://www.javashitang.com/md/java/%E8%AF%B4%E4%B8%80%E4%B8%8BSpring%20Boot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%8A%8A.html">面试官：说一下 Spring Boot 的启动过程吧</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904099897409550">SpringBoot 的启动流程是怎样的？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.processon.com/mindmap/64c722e964bc1858277b29d0">processOn</a></p>
<ol>
<li><p> 创建 SpringApplication 对象</p>
<ul>
<li>确定应用类型（Servlet、Reactive、None）</li>
<li>设置初始化器（Initializers）</li>
<li>设置监听器（Listeners）</li>
</ul>
</li>
<li><p>执行 SpringApplication 对象的 <code>run</code> 方法</p>
</li>
</ol>
<ul>
<li>获取监听器，发送 <code>ApplicationStartingEvent</code> 事件</li>
<li>准备环境 (<code>prepareEnvironment</code>)，创建 StandardServletEnvironment 对象，发送 <code>ApplicationEnvironmentPreparedEvent</code> 事件</li>
<li>创建 IOC 容器 ApplicationContext (<code>createApplicationContext</code>)，类名为 <code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>准备容器 (<code>prepareContext</code>)，调用初始化器，发送事件 <code>ApplicationPreparedEvent</code>，加载资源，发送事件 <code>ApplicationPreparedEvent</code></li>
<li>刷新容器 (<code>refreshContext</code>) – <strong>重要</strong><ul>
<li>获取 beanFactory (<code>obtainFreshBeanFactory</code>)，为 <code>DefaultListableBeanFactory</code></li>
<li>准备 beanFactory (<code>prepareBeanFactory</code>)</li>
<li> 调用 beanFactory 后置处理 (<code>invokeBeanFactoryPostProcessors</code>)，先处理 BeanDefinitionRegistryPostProcessor 相关的，调用 <code>postProcessBeanDefinitionRegistry</code> 处理 Bean 的定义（在 Bean 定义注册之前）；后处理 BeanFactoryPostProcessor 相关的，调用 <code>postProcessBeanFactory</code>（在 Bean 定义之后、实例化之前）</li>
<li>注册 Bean 的后置处理器 (<code>registerBeanPostProcessors</code>)，创建了 BeanPostProcessor 类型的对象</li>
<li>初始化 MessageSource 组件 (<code>initMessageSource</code>)</li>
<li> 初始化 ApplicationEventMulticaster (<code>initApplicationEventMulticaster</code>)</li>
<li> 初始化特殊的 Bean (<code>onRefresh</code>)，执行 <code>ServletWebServerApplicationContext#onRefresh</code> 启动 tomcat</li>
<li> 注册监听器 (<code>registerListeners</code>)</li>
<li> 初始化剩下的普通单例 (<code>finishBeanFactoryInitialization</code>)</li>
<li> 容器刷新完成 (<code>finishRefresh</code>)</li>
</ul>
</li>
<li> 发送 <code>ApplicationStartedEvent</code> 事件</li>
<li>回调 Runner 方法 (<code>callRunners</code>)，ApplicationRunner、CommandLineRunner</li>
<li> 返回容器</li>
</ul>
<p><strong>SpringApplication 的创建</strong></p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-1.png"></p>
<p><strong>SpringApplication 的启动</strong></p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-2.png"></p>
<p><strong>SpringBoot 完整启动过程</strong></p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/spring-boot-start-3.png"></p>
<h3 id="7-4-过滤器和拦截器有什么区别"><a href="#7-4-过滤器和拦截器有什么区别" class="headerlink" title="7.4 过滤器和拦截器有什么区别"></a>7.4 过滤器和拦截器有什么区别</h3><p><strong>什么是过滤器（Filter）？</strong></p>
<p>与 Servlet 相似，过滤器是一些 web 应用程序组件，可以绑定到一个 web 应用程序中。但是与其他 web 应用组件不同的是，过滤器是 “链” 在容器的处理过程中的。这就意味着它们可以在请求达到 Servlet 之前对其进行访问，也可以在响应信息返回到客户端之前对其进行拦截。这种访问使得过滤器可以检查并修改请求和响应的内容。</p>
<p><strong>什么是拦截器（Interceptor）？</strong></p>
<p>拦截器是 AOP 的一种实现策略，用于在某个方法或字段被访问前对它进行拦截，然后在其之前或之后加上某些操作。同 Filter 一样，Interceptor 也是链式调用。每个 Interceptor 的调用会依据它的声明顺序依次执行。一般来说拦截器可以用于以下方面 ：</p>
<ul>
<li>日志记录 ：记录请求信息的日志，以便进行信息监控、信息统计等</li>
<li>权限检查 ：对用户的访问权限，认证，或授权等进行检查</li>
<li>性能监控 ：通过拦截器在进入处理器前后分别记录开始时间和结束时间，从而得到请求的处理时间</li>
<li>通用行为 ：读取 cookie 得到用户信息并将用户对象放入请求头中，从而方便后续流程使用</li>
</ul>
<p><strong>区别？</strong></p>
<p>两者最大的区别在于：<strong>过滤器是在 Servlet 规范中定义的，是由 Servlet 容器支持的，只能用于过滤请求；拦截器是在 Spring 容器内的，由 Spring 框架支持。</strong></p>
<ul>
<li><strong>过滤器作用于请求到达 Servlet 之前，在 Spring 中也就是在 DispacherServlet 之前。</strong></li>
<li><strong>拦截器最早只能作用于请求到达 Servlet 之后。</strong></li>
</ul>
<p>拦截器作为 Spring 的一个组件，可以通过 IOC 容器进行管理，获取其中的各个 bean 实例，对 Spring 中的各种资源、对象，如 Service 对象、数据源、事务管理等进行调用；而过滤器则不能。</p>
<p>总的来说，两者主要在如下方面存在着差异 ：</p>
<ul>
<li>过滤器是基于函数的回调，而拦截器是基于 Java 反射机制的</li>
<li>过滤器可以修改 Request，而拦截器则不能</li>
<li>过滤器需要在 Servlet 容器中实现，拦截器可以适用于 JavaEE、JavaSE 等各种环境</li>
<li>拦截器可以调用 IOC 容器中的各种依赖，而过滤器不能</li>
<li>过滤器只能在请求的前后使用，而拦截器可以详细到每个方法 </li>
</ul>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/filterandinterceptor.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903991478861831">Spring 中的过滤器与拦截器</a></p>
<h3 id="7-5-SpringBoot-自动配置原理"><a href="#7-5-SpringBoot-自动配置原理" class="headerlink" title="7.5 SpringBoot 自动配置原理"></a>7.5 SpringBoot 自动配置原理</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">SpringBoot 自动装配原理详解</a></p>
<h3 id="7-6-Spring-IoC-容器中-Bean-的生命周期"><a href="#7-6-Spring-IoC-容器中-Bean-的生命周期" class="headerlink" title="7.6 Spring IoC 容器中 Bean 的生命周期"></a>7.6 Spring IoC 容器中 Bean 的生命周期</h3><p><a target="_blank" rel="noopener" href="https://chaycao.github.io/2020/02/15/%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BF%86Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html">如何记忆 Spring Bean 的生命周期</a></p>
<p>Bean 的生命周期概括起来就是 <strong>4 个阶段</strong>：</p>
<ol>
<li>实例化（Instantiation）</li>
<li>属性赋值（Populate）</li>
<li>初始化（Initialization）</li>
<li>销毁（Destruction）</li>
</ol>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/Spring%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<ol>
<li>实例化：第 1 步，实例化一个 bean 对象；</li>
<li>属性赋值：第 2 步，为 bean 设置相关属性和依赖；</li>
<li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；</li>
<li>销毁：第 8~10 步，第 8 步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第 9、10 步真正销毁 bean 时再执行相应的方法。</li>
</ol>
<h3 id="7-7-SpringMVC-的工作流程"><a href="#7-7-SpringMVC-的工作流程" class="headerlink" title="7.7 SpringMVC 的工作流程"></a>7.7 SpringMVC 的工作流程</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8a20c547e245">SpringMVC 执行流程及工作原理</a></p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p>
<h2 id="8-计算机网络"><a href="#8-计算机网络" class="headerlink" title="8 计算机网络"></a>8 计算机网络</h2><h3 id="8-1-HTTP-版本"><a href="#8-1-HTTP-版本" class="headerlink" title="8.1 HTTP 版本"></a>8.1 HTTP 版本</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-http.html#%E4%B8%83%E3%80%81http-2-0">HTTP/2</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html#http-1-1-%E5%92%8C-http-2-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">HTTP/1.1 和 HTTP/2.0 有什么区别</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html#http-1-1-%E5%92%8C-http-2-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">HTTP/2.0 和 HTTP/3.0 有什么区别</a></p>
<h3 id="8-2-HTTPS"><a href="#8-2-HTTPS" class="headerlink" title="8.2 HTTPS"></a>8.2 HTTPS</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html#http-%E5%92%8C-https-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">HTTP 和 HTTPS 有什么区别</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/http-vs-https.html">HTTP vs HTTPS</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-http.html#%E5%85%AD%E3%80%81https">HTTPs</a></p>
<h3 id="8-3-HTTP-方法"><a href="#8-3-HTTP-方法" class="headerlink" title="8.3 HTTP 方法"></a>8.3 HTTP 方法</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-http.html#%E4%BA%8C%E3%80%81http-%E6%96%B9%E6%B3%95">HTTP 方法</a></p>
<h3 id="8-4-HTTP-的头"><a href="#8-4-HTTP-的头" class="headerlink" title="8.4 HTTP 的头"></a>8.4 HTTP 的头</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-http.html#%E5%9B%9B%E3%80%81http-%E9%A6%96%E9%83%A8">HTTP 首部</a></p>
<h3 id="8-5-HTTP-状态码"><a href="#8-5-HTTP-状态码" class="headerlink" title="8.5 HTTP 状态码"></a>8.5 HTTP 状态码</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-http.html#%E4%B8%89%E3%80%81http-%E7%8A%B6%E6%80%81%E7%A0%81">HTTP 状态码</a></p>
<h3 id="8-6-TCP-与-UDP"><a href="#8-6-TCP-与-UDP" class="headerlink" title="8.6 TCP 与 UDP"></a>8.6 TCP 与 UDP</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions2.html#tcp-%E4%B8%8E-udp">TCP 与 UDP</a></p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html">TCP 三次握手和四次挥手</a></p>
<h3 id="8-7-输入-URL-到页面加载过程"><a href="#8-7-输入-URL-到页面加载过程" class="headerlink" title="8.7 输入 URL 到页面加载过程"></a>8.7 输入 URL 到页面加载过程</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html#%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88-%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81">从输入 URL 到页面展示到底发生了什么</a></p>
<p><a target="_blank" rel="noopener" href="https://pdai.tech/md/develop/protocol/dev-protocol-url.html">输入 URL 到页面加载过程详解</a></p>
<h2 id="9-Linux"><a href="#9-Linux" class="headerlink" title="9 Linux"></a>9 Linux</h2><h3 id="9-1-常用命令"><a href="#9-1-常用命令" class="headerlink" title="9.1 常用命令"></a>9.1 常用命令</h3><p>查看剩余内存：<code>free -h</code></p>
<p>显示目前所有文件系统的可用空间及使用情形：<code>df -h</code></p>
<p>查看某个路径下所有文件大小：<code>du -h --max-depth=1 .</code></p>
<p>chown</p>
<p>chmod</p>
<p>mount</p>
<p>tail</p>
<p>cat</p>
<h3 id="9-2-修改执行权限"><a href="#9-2-修改执行权限" class="headerlink" title="9.2 修改执行权限"></a>9.2 修改执行权限</h3><p>通过 <strong><code>ls -lah</code></strong> 命令可以查看某个目录下的文件或目录的权限。</p>
<p><img src="/2020/Java-%E9%9D%A2%E8%AF%95/linux_quanxian.jpg"></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="https://javaguide.cn/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB-7c1098a0.png"></p>
<p><strong>文件的类型：</strong></p>
<ul>
<li><code>d</code>： 代表目录</li>
<li><code>-</code>： 代表文件</li>
<li><code>l</code>： 代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p><strong>Linux 中权限分为以下几种</strong></p>
<ul>
<li><code>r</code>：代表权限是可读，<code>r</code> 也可以用数字 4 表示</li>
<li><code>w</code>：代表权限是可写，<code>w</code> 也可以用数字 2 表示</li>
<li><code>x</code>：代表权限是可执行，<code>x</code> 也可以用数字 1 表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td> r</td>
<td> 可以使用 cat 查看文件的内容</td>
</tr>
<tr>
<td> w</td>
<td> 可以修改文件的内容</td>
</tr>
<tr>
<td> x</td>
<td> 可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td> r</td>
<td> 可以查看目录下列表</td>
</tr>
<tr>
<td> w</td>
<td> 可以创建和删除目录下文件</td>
</tr>
<tr>
<td> x</td>
<td> 可以使用 cd 进入目录</td>
</tr>
</tbody></table>
<p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>
<p><strong>修改文件 / 目录的权限的命令</strong>：<code>chmod</code></p>
<p>示例：修改 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><code>chmod u=rwx,g=rw,o=r aaa.txt</code> 或者 <code>chmod 764 aaa.txt</code></p>
<h2 id="10-MyBatis"><a href="#10-MyBatis" class="headerlink" title="10 MyBatis"></a>10 MyBatis</h2><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5e4e3b7ae4b0369b916b2e71#map">MyBatis 面试常见问题</a></p>
<h3 id="10-1-MyBatis-怎么防止-SQL-注入"><a href="#10-1-MyBatis-怎么防止-SQL-注入" class="headerlink" title="10.1 MyBatis 怎么防止 SQL 注入"></a>10.1 MyBatis 怎么防止 SQL 注入</h3><p>MyBatis 中使用 <code>#{}</code> 防止 SQL 注入</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResultMap("BaseResultMap")</span></span><br><span class="line"><span class="meta">@Select("select * from user where username = #{username}")</span></span><br><span class="line">User <span class="title function_">getUserByParas1</span><span class="params">(<span class="meta">@Param("username")</span> String username)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResultMap("BaseResultMap")</span></span><br><span class="line"><span class="meta">@Select("select * from user where username = ${username}")</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByParas2</span><span class="params">(<span class="meta">@Param("username")</span> String username)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>#{} </code>使用了 <code>PreparedStatement</code> 来进行预处理，然后通过 set 的方式对占位符进行设置，而 <code>${}</code> 则是通过 <code>Statement</code> 直接进行查询，当有参数时直接拼接进行查询。</p>
<ul>
<li>Mybatis 中使用 <code>#{}</code> 可以防止 SQL 注入，<code>${}</code> 并不能防止 SQL 注入</li>
<li> Mybatis 实现防止 SQL 注入的原理是调用了 JDBC 中的 <code>PreparedStatement</code> 来进行预处理。</li>
</ul>
<h3 id="10-2-实体类的属性名和表中的字段名不一样怎么办"><a href="#10-2-实体类的属性名和表中的字段名不一样怎么办" class="headerlink" title="10.2 实体类的属性名和表中的字段名不一样怎么办"></a>10.2 实体类的属性名和表中的字段名不一样怎么办</h3><p>TO DO</p>
<h3 id="10-3-缓存"><a href="#10-3-缓存" class="headerlink" title="10.3 缓存"></a>10.3 缓存</h3><p>TO DO</p>
<h2 id="11-消息队列"><a href="#11-消息队列" class="headerlink" title="11 消息队列"></a>11 消息队列</h2><h3 id="11-1-为什么要使用消息队列"><a href="#11-1-为什么要使用消息队列" class="headerlink" title="11.1 为什么要使用消息队列"></a>11.1 为什么要使用消息队列</h3><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/84f9538c7468ed89434c68686">消息队列（一）为什么要使用消息队列？</a></p>
<h3 id="11-2-如何保证消息的顺序性"><a href="#11-2-如何保证消息的顺序性" class="headerlink" title="11.2 如何保证消息的顺序性"></a>11.2 如何保证消息的顺序性</h3><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/c84491a814f99c7b9965732b1">消息队列（五）如何保证消息的顺序性？</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><strong>红黑树特点</strong></p>
<ol>
<li>每个节点非红即黑</li>
<li>根节点总是黑色的</li>
<li>每个叶子节点都是黑色的空节点（NIL 节点）</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li>
</ol>
<p><strong>红黑树的应用</strong></p>
<p>TreeMap、TreeSet 以及 JDK1.8 的 HashMap、ConcurrentHashMap 底层都用到了红黑树。</p>
<p><strong>为什么要用红黑树？</strong></p>
<p>简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/-8JFh5iLr88XA4AJ9mMf6g">图解红黑树</a></p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><a target="_blank" rel="noopener" href="https://pdai.tech/md/algorithm/alg-sort-overview.html">常见排序算法知识体系详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/85460755">排序算法时间复杂度、空间复杂度、稳定性比较</a></p>
<table>
<thead>
<tr>
<th><strong>排序算法</strong></th>
<th><strong>平均时间复杂度</strong></th>
<th><strong>最坏时间复杂度</strong></th>
<th><strong>最好时间复杂度</strong></th>
<th><strong>空间复杂度</strong></th>
<th><strong>稳定性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>冒泡排序</strong></td>
<td> O(n²)</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(1)</td>
<td> 稳定</td>
</tr>
<tr>
<td><strong>直接选择排序</strong></td>
<td> O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td> 不稳定</td>
</tr>
<tr>
<td><strong>直接插入排序</strong></td>
<td> O(n²)</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(1)</td>
<td> 稳定</td>
</tr>
<tr>
<td><strong>快速排序</strong></td>
<td> O(nlogn)</td>
<td>O(n²)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td> 不稳定</td>
</tr>
<tr>
<td><strong>堆排序</strong></td>
<td> O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td> 不稳定</td>
</tr>
<tr>
<td><strong>希尔排序</strong></td>
<td> O(nlogn)</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(1)</td>
<td> 不稳定</td>
</tr>
<tr>
<td><strong>归并排序</strong></td>
<td> O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td> 稳定</td>
</tr>
<tr>
<td><strong>计数排序</strong></td>
<td> O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td> 稳定</td>
</tr>
<tr>
<td><strong>基数排序</strong></td>
<td> O(N*M)</td>
<td>O(N*M)</td>
<td>O(N*M)</td>
<td>O(M)</td>
<td> 稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>注：基数排序时间复杂度为 O (N*M)，其中 N 为数据个数，M 为数据位数。</p>
<p>直接选择排序的时间复杂度与初始序列无关，都为 O (n²)</p>
</blockquote>
<p><strong>辅助记忆</strong></p>
<ul>
<li><p>时间复杂度记忆</p>
<ol>
<li>冒泡、选择、插入排序需要两个 for 循环，每次只关注一个元素，平均时间复杂度为 O (n²)（一遍找元素 O (n)，一遍找位置 O (n)）</li>
<li>快速、归并、希尔、堆基于二分思想，log 以 2 为底，平均时间复杂度为 O (nlogn)（一遍找元素 O (n)，一遍找位置 O (logn)）</li>
</ol>
</li>
<li><p>稳定性记忆</p>
<p>快速排序、希尔排序、选择排序、堆排序，不稳定 </p>
<p>“快希选堆”（快牺牲稳定性）</p>
</li>
</ul>
<p><strong>快速排序是最快的通用排序算法</strong>，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为～cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p>
<p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p>
<h3 id="LRU-算法"><a href="#LRU-算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34133067">LRU 原理和 Redis 实现</a></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRU</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRU</span><span class="params">(<span class="type">int</span> cacheSize)</span> {</span><br><span class="line">        <span class="comment">// true 表示按访问顺序排序，最近访问放在头部，最老访问放在尾部</span></span><br><span class="line">        <span class="built_in">super</span>((<span class="type">int</span>)Math.ceil(cacheSize / <span class="number">0.75</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        CACHE_SIZE = cacheSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> {</span><br><span class="line">        <span class="comment">// 当容量大于设定好的 cache size 时删除最早的节点</span></span><br><span class="line">        <span class="keyword">return</span> size() &gt; CACHE_SIZE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">图说设计模式</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN#rd">面试官：“谈谈 Spring 中都用到了那些设计模式？”</a></p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>好处：</p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p>1、饿汉式：全局的单例实例在类装载时构建（线程安全）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户无法通过 new 方法创建该对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstence</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、懒汉式（线程不安全）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3、懒汉式：双重检查（线程安全）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line">    <span class="comment">// volatile保证当 instance 变量被初始化成 Singleton 实例时，多个线程可以正确处理 instance 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>4、懒汉式：静态内部类（线程安全）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>5、枚举（线程安全，也能防止反序列化导致重新创建新的对象）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>{</span><br><span class="line">    INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><h3 id="求最大公约数和最小公倍数"><a href="#求最大公约数和最小公倍数" class="headerlink" title="求最大公约数和最小公倍数"></a>求最大公约数和最小公倍数</h3><p>最大公约数 GCD：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 递归求最大公约数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">GCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> GCD(b, a % b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 辗转相除法求最大公约数</span></span><br><span class="line"><span class="comment">  * 有两整数 a 和 b：</span></span><br><span class="line"><span class="comment">  *  1. a % b 得余数 c</span></span><br><span class="line"><span class="comment">  *  2. 若 c = 0，则 b 即为两数的最大公约数</span></span><br><span class="line"><span class="comment">  *  3. 若 c != 0，则 a = b，b = c，再回去执行 1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divisionGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) {</span><br><span class="line">        c = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 相减法求最大公约数</span></span><br><span class="line"><span class="comment">  * 有两整数 a 和 b：</span></span><br><span class="line"><span class="comment">  *  1. 若 a &gt; b，则 a = a - b</span></span><br><span class="line"><span class="comment">  *  2. 若 a &lt; b，则 b = b - a</span></span><br><span class="line"><span class="comment">  *  3. 若 a = b，则 a（或 b）即为两数的最大公约数</span></span><br><span class="line"><span class="comment">  *  4. 若 a != b，则再回去执行 1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtractionGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="keyword">while</span> (a != b) {</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) {</span><br><span class="line">            a = a - b;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            b = b - a;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最小公倍数 LCM：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LCM</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> {</span><br><span class="line">    <span class="keyword">return</span> a * b / GCD(a, b);</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>

<h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p>用三个线程，顺序打印字母 A-Z，输出结果是 1A 2B 3C 1D 2E…</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(Thread.currentThread().getName());</span><br><span class="line">                        <span class="keyword">while</span> (i &lt; <span class="number">26</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (i % <span class="number">3</span> == id - <span class="number">1</span>) {</span><br><span class="line">                                System.out.println(<span class="string">"线程: "</span> + id + <span class="string">" "</span> + c++);</span><br><span class="line">                                i++;</span><br><span class="line">                                notifyAll();</span><br><span class="line">                            } <span class="keyword">else</span> {</span><br><span class="line">                                wait();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">"1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">"2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable, <span class="string">"3"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





</div><div class="article-licensing box"><div class="licensing-title"><p>一些容易忘掉的知识点 - Java</p><p><a href="https://morooi.com/2020/Java-面试/">https://morooi.com/2020/Java-面试/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>SJ Zhou</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-08-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-21</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/docker-maven/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">使用 dockerfile-maven-plugin 插件构建并推送 Docker 镜像</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/%E6%90%AD%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"><span class="level-item">使用 Docker 自建支持 DoH、DoT 的 DNS 服务器</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "cc58364382a2f1f1f5a9109a829368b8",
            repo: "morooi.github.io",
            owner: "morooi",
            clientID: "5f226401a110e7b4a6bc",
            clientSecret: "61c075c74df925c0ee95072d8d649dad5eb5587e",
            admin: ["morooi"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.jpg" alt="morooi"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">morooi</p><p class="is-size-6 is-block">morooi&#039;s Blog</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">36</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/morooi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/morooi_"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Telegram" href="https://t.me/morooi"><i class="fab fa-telegram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/zhoushaojing"><i class="fab fa-weibo"></i></a></div></div></div><div class="card widget is-sticky" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-Java-基础"><span class="level-left"><span class="level-item">1 Java 基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-快速失败（fail-fast）和安全失败（fail-safe）机制"><span class="level-left"><span class="level-item">1.1 快速失败（fail-fast）和安全失败（fail-safe）机制</span></span></a></li><li><a class="level is-mobile" href="#1-2-HashMap-与-ConcurrentHashMap-对-null-值的处理问题"><span class="level-left"><span class="level-item">1.2 HashMap 与 ConcurrentHashMap 对 null 值的处理问题</span></span></a></li><li><a class="level is-mobile" href="#1-3-Arrays-asList"><span class="level-left"><span class="level-item">1.3 Arrays.asList()</span></span></a></li><li><a class="level is-mobile" href="#1-4-Java-中用到的排序算法"><span class="level-left"><span class="level-item">1.4 Java 中用到的排序算法</span></span></a></li><li><a class="level is-mobile" href="#1-5-BIO、NIO"><span class="level-left"><span class="level-item">1.5 BIO、NIO</span></span></a></li><li><a class="level is-mobile" href="#1-6-HashMap-的-put-方法"><span class="level-left"><span class="level-item">1.6 HashMap 的 put () 方法</span></span></a></li><li><a class="level is-mobile" href="#1-7-HashMap-的-resize-方法"><span class="level-left"><span class="level-item">1.7 HashMap 的 resize () 方法</span></span></a></li><li><a class="level is-mobile" href="#1-8-HashMap-获取所有的-Key"><span class="level-left"><span class="level-item">1.8 HashMap 获取所有的 Key</span></span></a></li><li><a class="level is-mobile" href="#1-9-ConcurrentHashMap"><span class="level-left"><span class="level-item">1.9 ConcurrentHashMap</span></span></a></li><li><a class="level is-mobile" href="#1-10-内部类有什么作用"><span class="level-left"><span class="level-item">1.10 内部类有什么作用</span></span></a></li><li><a class="level is-mobile" href="#1-11-创建对象的几种方式"><span class="level-left"><span class="level-item">1.11 创建对象的几种方式</span></span></a></li><li><a class="level is-mobile" href="#1-12-双亲委派机制"><span class="level-left"><span class="level-item">1.12 双亲委派机制</span></span></a></li><li><a class="level is-mobile" href="#1-13-实现只读集合"><span class="level-left"><span class="level-item">1.13 实现只读集合</span></span></a></li><li><a class="level is-mobile" href="#1-14-接口和抽象类的区别"><span class="level-left"><span class="level-item">1.14 接口和抽象类的区别</span></span></a></li><li><a class="level is-mobile" href="#1-15-类的生命周期、类加载过程"><span class="level-left"><span class="level-item">1.15 类的生命周期、类加载过程</span></span></a></li><li><a class="level is-mobile" href="#1-16-几个容器的声明"><span class="level-left"><span class="level-item">1.16 几个容器的声明</span></span></a></li><li><a class="level is-mobile" href="#1-17-StringBuilder-和-StringBuffer-的区别"><span class="level-left"><span class="level-item">1.17 StringBuilder 和 StringBuffer 的区别</span></span></a></li><li><a class="level is-mobile" href="#1-18-错误与异常"><span class="level-left"><span class="level-item">1.18 错误与异常</span></span></a></li><li><a class="level is-mobile" href="#1-19-String-类的一些用法"><span class="level-left"><span class="level-item">1.19 String 类的一些用法</span></span></a></li><li><a class="level is-mobile" href="#1-20-线程安全的容器"><span class="level-left"><span class="level-item">1.20 线程安全的容器</span></span></a></li><li><a class="level is-mobile" href="#1-21-HashMap-为什么线程不安全"><span class="level-left"><span class="level-item">1.21 HashMap 为什么线程不安全</span></span></a></li><li><a class="level is-mobile" href="#1-22-HashMap-为什么扩容总是-2-的幂次"><span class="level-left"><span class="level-item">1.22 HashMap 为什么扩容总是 2 的幂次</span></span></a></li><li><a class="level is-mobile" href="#1-23-HashMap-为什么要用红黑树-不用其他树"><span class="level-left"><span class="level-item">1.23 HashMap 为什么要用红黑树 不用其他树</span></span></a></li><li><a class="level is-mobile" href="#1-24-HashMap-为什么到-8-的时候变为红黑树"><span class="level-left"><span class="level-item">1.24 HashMap 为什么到 8 的时候变为红黑树</span></span></a></li><li><a class="level is-mobile" href="#1-25-符号引用和直接引用"><span class="level-left"><span class="level-item">1.25 符号引用和直接引用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-多线程"><span class="level-left"><span class="level-item">2 多线程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-sleep-、wait-、join-的区别"><span class="level-left"><span class="level-item">2.1 sleep ()、wait ()、join () 的区别</span></span></a></li><li><a class="level is-mobile" href="#2-2-线程的生命周期和状态"><span class="level-left"><span class="level-item">2.2 线程的生命周期和状态</span></span></a></li><li><a class="level is-mobile" href="#2-3-锁升级"><span class="level-left"><span class="level-item">2.3 锁升级</span></span></a></li><li><a class="level is-mobile" href="#2-4-线程为什么比进程快"><span class="level-left"><span class="level-item">2.4 线程为什么比进程快</span></span></a></li><li><a class="level is-mobile" href="#2-5-使用多线程的好处"><span class="level-left"><span class="level-item">2.5 使用多线程的好处</span></span></a></li><li><a class="level is-mobile" href="#2-6-使用多线程可能会带来的问题"><span class="level-left"><span class="level-item">2.6 使用多线程可能会带来的问题</span></span></a></li><li><a class="level is-mobile" href="#2-7-synchronized-与-Lock-的区别"><span class="level-left"><span class="level-item">2.7 synchronized 与 Lock 的区别</span></span></a></li><li><a class="level is-mobile" href="#2-8-线程池"><span class="level-left"><span class="level-item">2.8 线程池</span></span></a></li><li><a class="level is-mobile" href="#2-9-ThreadLocal"><span class="level-left"><span class="level-item">2.9 ThreadLocal</span></span></a></li><li><a class="level is-mobile" href="#2-10-volatile"><span class="level-left"><span class="level-item">2.10 volatile</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-JVM"><span class="level-left"><span class="level-item">3 JVM</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-CMS-收集器"><span class="level-left"><span class="level-item">3.1 CMS 收集器</span></span></a></li><li><a class="level is-mobile" href="#3-2-G1-收集器"><span class="level-left"><span class="level-item">3.2 G1 收集器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#G1堆内存结构"><span class="level-left"><span class="level-item">G1 堆内存结构</span></span></a></li><li><a class="level is-mobile" href="#G1堆内存分配"><span class="level-left"><span class="level-item">G1 堆内存分配</span></span></a></li><li><a class="level is-mobile" href="#G1回收流程"><span class="level-left"><span class="level-item">G1 回收流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-Java-内存中各部分的内容"><span class="level-left"><span class="level-item">3.3 Java 内存中各部分的内容</span></span></a></li><li><a class="level is-mobile" href="#3-4-永久代会有垃圾回收吗"><span class="level-left"><span class="level-item">3.4 永久代会有垃圾回收吗</span></span></a></li><li><a class="level is-mobile" href="#3-5-JDK-8-的默认垃圾回收器"><span class="level-left"><span class="level-item">3.5 JDK 8 的默认垃圾回收器</span></span></a></li><li><a class="level is-mobile" href="#3-6-JVM-思维导图"><span class="level-left"><span class="level-item">3.6 JVM 思维导图</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-数据库"><span class="level-left"><span class="level-item">4 数据库</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-MyISAM-与-InnoDB-的区别"><span class="level-left"><span class="level-item">4.1 MyISAM 与 InnoDB 的区别</span></span></a></li><li><a class="level is-mobile" href="#4-2-数据库事务"><span class="level-left"><span class="level-item">4.2 数据库事务</span></span></a></li><li><a class="level is-mobile" href="#4-3-数据库索引"><span class="level-left"><span class="level-item">4.3 数据库索引</span></span></a></li><li><a class="level is-mobile" href="#4-4-SQL-语句的执行过程"><span class="level-left"><span class="level-item">4.4 SQL 语句的执行过程</span></span></a></li><li><a class="level is-mobile" href="#4-5-MySQL-的锁机制"><span class="level-left"><span class="level-item">4.5 MySQL 的锁机制</span></span></a></li><li><a class="level is-mobile" href="#4-6-MVCC-多版本并发控制"><span class="level-left"><span class="level-item">4.6 MVCC 多版本并发控制</span></span></a></li><li><a class="level is-mobile" href="#4-7-delete-truncate-drop-删除的区别"><span class="level-left"><span class="level-item">4.7 delete , truncate,  drop 删除的区别</span></span></a></li><li><a class="level is-mobile" href="#4-8-内连接、左连接、右连接"><span class="level-left"><span class="level-item">4.8 内连接、左连接、右连接</span></span></a></li><li><a class="level is-mobile" href="#4-9-MySQL-中的常用函数"><span class="level-left"><span class="level-item">4.9 MySQL 中的常用函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#5-分布式"><span class="level-left"><span class="level-item">5 分布式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-分布式架构"><span class="level-left"><span class="level-item">5.1 分布式架构</span></span></a></li><li><a class="level is-mobile" href="#5-2-分布式事务"><span class="level-left"><span class="level-item">5.2 分布式事务</span></span></a></li><li><a class="level is-mobile" href="#5-3-Spring-Cloud-技术图"><span class="level-left"><span class="level-item">5.3 Spring Cloud 技术图</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-Redis"><span class="level-left"><span class="level-item">6 Redis</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-数据库的双写一致性问题"><span class="level-left"><span class="level-item">6.1 数据库的双写一致性问题</span></span></a></li><li><a class="level is-mobile" href="#6-2-RDB-与-AOF"><span class="level-left"><span class="level-item">6.2 RDB 与 AOF</span></span></a></li><li><a class="level is-mobile" href="#6-3-数据结构"><span class="level-left"><span class="level-item">6.3 数据结构</span></span></a></li><li><a class="level is-mobile" href="#6-4-Redis-集群"><span class="level-left"><span class="level-item">6.4 Redis 集群</span></span></a></li><li><a class="level is-mobile" href="#6-5-Redis-过期-key-的删除策略"><span class="level-left"><span class="level-item">6.5 Redis 过期 key 的删除策略</span></span></a></li><li><a class="level is-mobile" href="#6-6-内存淘汰机制"><span class="level-left"><span class="level-item">6.6 内存淘汰机制</span></span></a></li><li><a class="level is-mobile" href="#6-7-scan-命令"><span class="level-left"><span class="level-item">6.7 scan 命令</span></span></a></li><li><a class="level is-mobile" href="#6-8-异步队列和延迟队列"><span class="level-left"><span class="level-item">6.8 异步队列和延迟队列</span></span></a></li><li><a class="level is-mobile" href="#6-9-Redis-线程模型"><span class="level-left"><span class="level-item">6.9 Redis 线程模型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-Spring-全家桶"><span class="level-left"><span class="level-item">7 Spring 全家桶</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-Spring-中依赖注入的方式"><span class="level-left"><span class="level-item">7.1 Spring 中依赖注入的方式</span></span></a></li><li><a class="level is-mobile" href="#7-2-Spring-如何解决循环依赖"><span class="level-left"><span class="level-item">7.2 Spring 如何解决循环依赖</span></span></a></li><li><a class="level is-mobile" href="#7-3-SpringBoot-的启动流程"><span class="level-left"><span class="level-item">7.3 SpringBoot 的启动流程</span></span></a></li><li><a class="level is-mobile" href="#7-4-过滤器和拦截器有什么区别"><span class="level-left"><span class="level-item">7.4 过滤器和拦截器有什么区别</span></span></a></li><li><a class="level is-mobile" href="#7-5-SpringBoot-自动配置原理"><span class="level-left"><span class="level-item">7.5 SpringBoot 自动配置原理</span></span></a></li><li><a class="level is-mobile" href="#7-6-Spring-IoC-容器中-Bean-的生命周期"><span class="level-left"><span class="level-item">7.6 Spring IoC 容器中 Bean 的生命周期</span></span></a></li><li><a class="level is-mobile" href="#7-7-SpringMVC-的工作流程"><span class="level-left"><span class="level-item">7.7 SpringMVC 的工作流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#8-计算机网络"><span class="level-left"><span class="level-item">8 计算机网络</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#8-1-HTTP-版本"><span class="level-left"><span class="level-item">8.1 HTTP 版本</span></span></a></li><li><a class="level is-mobile" href="#8-2-HTTPS"><span class="level-left"><span class="level-item">8.2 HTTPS</span></span></a></li><li><a class="level is-mobile" href="#8-3-HTTP-方法"><span class="level-left"><span class="level-item">8.3 HTTP 方法</span></span></a></li><li><a class="level is-mobile" href="#8-4-HTTP-的头"><span class="level-left"><span class="level-item">8.4 HTTP 的头</span></span></a></li><li><a class="level is-mobile" href="#8-5-HTTP-状态码"><span class="level-left"><span class="level-item">8.5 HTTP 状态码</span></span></a></li><li><a class="level is-mobile" href="#8-6-TCP-与-UDP"><span class="level-left"><span class="level-item">8.6 TCP 与 UDP</span></span></a></li><li><a class="level is-mobile" href="#8-7-输入-URL-到页面加载过程"><span class="level-left"><span class="level-item">8.7 输入 URL 到页面加载过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#9-Linux"><span class="level-left"><span class="level-item">9 Linux</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#9-1-常用命令"><span class="level-left"><span class="level-item">9.1 常用命令</span></span></a></li><li><a class="level is-mobile" href="#9-2-修改执行权限"><span class="level-left"><span class="level-item">9.2 修改执行权限</span></span></a></li></ul></li><li><a class="level is-mobile" href="#10-MyBatis"><span class="level-left"><span class="level-item">10 MyBatis</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#10-1-MyBatis-怎么防止-SQL-注入"><span class="level-left"><span class="level-item">10.1 MyBatis 怎么防止 SQL 注入</span></span></a></li><li><a class="level is-mobile" href="#10-2-实体类的属性名和表中的字段名不一样怎么办"><span class="level-left"><span class="level-item">10.2 实体类的属性名和表中的字段名不一样怎么办</span></span></a></li><li><a class="level is-mobile" href="#10-3-缓存"><span class="level-left"><span class="level-item">10.3 缓存</span></span></a></li></ul></li><li><a class="level is-mobile" href="#11-消息队列"><span class="level-left"><span class="level-item">11 消息队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#11-1-为什么要使用消息队列"><span class="level-left"><span class="level-item">11.1 为什么要使用消息队列</span></span></a></li><li><a class="level is-mobile" href="#11-2-如何保证消息的顺序性"><span class="level-left"><span class="level-item">11.2 如何保证消息的顺序性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#其他"><span class="level-left"><span class="level-item">其他</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#红黑树"><span class="level-left"><span class="level-item">红黑树</span></span></a></li><li><a class="level is-mobile" href="#排序算法"><span class="level-left"><span class="level-item">排序算法</span></span></a></li><li><a class="level is-mobile" href="#LRU-算法"><span class="level-left"><span class="level-item">LRU 算法</span></span></a></li><li><a class="level is-mobile" href="#设计模式"><span class="level-left"><span class="level-item">设计模式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#单例模式"><span class="level-left"><span class="level-item">单例模式</span></span></a></li><li><a class="level is-mobile" href="#工厂模式"><span class="level-left"><span class="level-item">工厂模式</span></span></a></li><li><a class="level is-mobile" href="#观察者模式"><span class="level-left"><span class="level-item">观察者模式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#求最大公约数和最小公倍数"><span class="level-left"><span class="level-item">求最大公约数和最小公倍数</span></span></a></li><li><a class="level is-mobile" href="#多线程编程"><span class="level-left"><span class="level-item">多线程编程</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Linux-%E4%BD%BF%E7%94%A8/"><span class="level-start"><span class="level-item">Linux 使用</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="level-start"><span class="level-item">大数据</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">学习笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">记录</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-05T06:15:06.000Z">2021-01-05</time></p><p class="title"><a href="/2021/acme-sh/">使用 acme.sh 自动签发 ZeroSSL 的 ECC 证书</a></p><p class="categories"><a href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-21T11:38:58.000Z">2020-12-21</time></p><p class="title"><a href="/2020/FixPD16/">解决 Parallels Desktop 16 by TNT 网络初始化失败的问题</a></p><p class="categories"><a href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-12-01T13:49:44.000Z">2020-12-01</time></p><p class="title"><a href="/2020/docker-maven/">使用 dockerfile-maven-plugin 插件构建并推送 Docker 镜像</a></p><p class="categories"><a href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-08-16T08:05:01.000Z">2020-08-16</time></p><p class="title"><a href="/2020/Java-%E9%9D%A2%E8%AF%95/">一些容易忘掉的知识点 - Java</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-07-13T11:34:37.000Z">2020-07-13</time></p><p class="title"><a href="/2020/%E6%90%AD%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用 Docker 自建支持 DoH、DoT 的 DNS 服务器</a></p><p class="categories"><a href="/categories/%E8%AE%B0%E5%BD%95/">记录</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">morooi&#039;s Blog</a><p class="is-size-7"><span>&copy; 2023 SJ Zhou</span>  <a target="_blank" href="https://beian.miit.gov.cn/">沪 ICP 备 2022003363 号</a><br>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">本网站由 <a href="https://www.aliyun.com/product/cdn" target="_blank"><img src="/img/aliyun_logo.png" style="height:15px;display:inline"></a>、<a href="https://www.cloudflare.com/cdn" target="_blank"><img src="/img/cloudflare_logo.svg" style="height:15px;display:inline"></a> 提供 CDN 加速服务</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>